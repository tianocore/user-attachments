From 476578b7d250bf2b00bfa7ff13d94a32c548f06d Mon Sep 17 00:00:00 2001
From: Dandan Bi <dandan.bi@intel.com>
Date: Mon, 28 Jun 2021 19:50:22 +0800
Subject: [patch] MdeModulePkg/Performance[CVE-2021-28216]: Lock boot
 performance table address variable at EndOfDxe

REF: https://bugzilla.tianocore.org/show_bug.cgi?id=2957

1. Allocate performance data table at EndOfDxe and then lock the varible
   which store the table address at EndOfDxe.

2. Enlarge PCD gEfiMdeModulePkgTokenSpaceGuid.PcdExtFpdtBootRecordPadSize
   from 0x20000 to 0x30000 in order to hold the Delta performance data
   between EndOfDxe and ReadyToBoot.

3. SMM performance data is collected by DXE modules through SMM communication
   at ReadyToBoot before.
   Now to do SMM communication twice, one for allocating the performance
   size at EndOfDxe, another is at ReadyToBoot to get SMM performance data.

4. Make SmmCorePerformanceLib rather than FirmwarePerformanceSmm to communicate
   with DxeCorePerformanceLib for SMM performance data and size.

Change-Id: Id0fdce67ceceb0b098e8f5a5f4786021ef45105f
Signed-off-by: Dandan Bi <dandan.bi@intel.com>
---
 .../DxeCorePerformanceLib.c                   | 132 +++++++++++----
 .../DxeCorePerformanceLib.inf                 |   3 +-
 .../SmmCorePerformanceLib.c                   | 142 +++++++++++++----
 .../SmmCorePerformanceLib.inf                 |   5 +-
 MdeModulePkg/MdeModulePkg.dec                 |   4 +-
 .../FirmwarePerformanceDxe.c                  |  90 +++++++++--
 .../FirmwarePerformanceDxe.inf                |   6 +-
 .../FirmwarePerformanceCommon.c               | 150 +-----------------
 .../FirmwarePerformanceCommon.h               |  17 +-
 .../FirmwarePerformanceSmm.inf                |   4 +-
 .../FirmwarePerformanceStandaloneMm.c         |  21 +--
 .../FirmwarePerformanceStandaloneMm.inf       |   4 +-
 .../FirmwarePerformanceTraditional.c          |  21 +--
 13 files changed, 306 insertions(+), 293 deletions(-)

diff --git a/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.c b/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.c
index d378c59dd9..532b3f8c90 100644
--- a/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.c
+++ b/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.c
@@ -8,11 +8,11 @@
   which are consumed by DxePerformanceLib to logging performance data in DXE phase.
 
   This library is mainly used by DxeCore to start performance logging to ensure that
   Performance Protocol is installed at the very beginning of DXE phase.
 
-Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
 (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
 SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
@@ -62,11 +62,11 @@ UINTN           mCachePairCount = 0;
 
 UINT32  mLoadImageCount       = 0;
 UINT32  mPerformanceLength    = 0;
 UINT32  mMaxPerformanceLength = 0;
 UINT32  mBootRecordSize       = 0;
-UINT32  mBootRecordMaxSize    = 0;
+UINTN   mBootRecordMaxSize    = 0;
 UINT32  mCachedLength         = 0;
 
 BOOLEAN mFpdtBufferIsReported = FALSE;
 BOOLEAN mLackSpaceIsReported  = FALSE;
 CHAR8   *mPlatformLanguage    = NULL;
@@ -203,29 +203,30 @@ IsKnownID (
     return FALSE;
   }
 }
 
 /**
-  Allocate buffer for Boot Performance table.
+  This internal function dumps all the SMM performance data and size.
 
-  @return Status code.
+  @param    SmmPerfData        Smm Performance data. The buffer contain the SMM perf data is allocated by this function and caller needs to free it.
+  @param    SmmPerfDataSize    Smm Performance data size.
+  @param    SkipGetPerfData    Skip to get performance data, just get the size.
 
 **/
-EFI_STATUS
-AllocateBootPerformanceTable (
+VOID
+InternalGetSmmPerfData (
+  OUT VOID      **SmmPerfData,
+  OUT UINTN     *SmmPerfDataSize,
+  IN  BOOLEAN   SkipGetPerfData
   )
 {
   EFI_STATUS                              Status;
-  UINTN                                   Size;
   UINT8                                   *SmmBootRecordCommBuffer;
   EFI_SMM_COMMUNICATE_HEADER              *SmmCommBufferHeader;
   SMM_BOOT_RECORD_COMMUNICATE             *SmmCommData;
   UINTN                                   CommSize;
-  UINTN                                   BootPerformanceDataSize;
-  UINT8                                   *BootPerformanceData;
   EFI_SMM_COMMUNICATION_PROTOCOL          *Communication;
-  FIRMWARE_PERFORMANCE_VARIABLE           PerformanceVariable;
   EDKII_PI_SMM_COMMUNICATION_REGION_TABLE *SmmCommRegionTable;
   EFI_MEMORY_DESCRIPTOR                   *SmmCommMemRegion;
   UINTN                                   Index;
   VOID                                    *SmmBootRecordData;
   UINTN                                   SmmBootRecordDataSize;
@@ -235,11 +236,10 @@ AllocateBootPerformanceTable (
   // Collect boot records from SMM drivers.
   //
   SmmBootRecordCommBuffer = NULL;
   SmmCommData             = NULL;
   SmmBootRecordData       = NULL;
-  SmmBootRecordDataSize   = 0;
   ReservedMemSize         = 0;
   Status = gBS->LocateProtocol (&gEfiSmmCommunicationProtocolGuid, NULL, (VOID **) &Communication);
   if (!EFI_ERROR (Status)) {
     //
     // Initialize communicate buffer
@@ -282,10 +282,14 @@ AllocateBootPerformanceTable (
         SmmCommData->Function       = SMM_FPDT_FUNCTION_GET_BOOT_RECORD_SIZE;
         SmmCommData->BootRecordData = NULL;
         Status = Communication->Communicate (Communication, SmmBootRecordCommBuffer, &CommSize);
 
         if (!EFI_ERROR (Status) && !EFI_ERROR (SmmCommData->ReturnStatus) && SmmCommData->BootRecordSize != 0) {
+          if (SkipGetPerfData) {
+            *SmmPerfDataSize = SmmCommData->BootRecordSize;
+            return;
+          }
           //
           // Get all boot records
           //
           SmmCommData->Function       = SMM_FPDT_FUNCTION_GET_BOOT_RECORD_DATA_BY_OFFSET;
           SmmBootRecordDataSize       = SmmCommData->BootRecordSize;
@@ -303,23 +307,49 @@ AllocateBootPerformanceTable (
             } else {
               CopyMem ((UINT8 *) SmmBootRecordData + SmmCommData->BootRecordOffset, SmmCommData->BootRecordData, SmmCommData->BootRecordSize);
             }
             SmmCommData->BootRecordOffset = SmmCommData->BootRecordOffset + SmmCommData->BootRecordSize;
           }
+          *SmmPerfData     = SmmBootRecordData;
+          *SmmPerfDataSize = SmmBootRecordDataSize;
         }
       }
     }
   }
+}
+
+/**
+  Allocate buffer for Boot Performance table.
+
+  @return Status code.
+
+**/
+EFI_STATUS
+AllocateBootPerformanceTable (
+  VOID
+  )
+{
+  EFI_STATUS                              Status;
+  UINTN                                   Size;
+  UINTN                                   BootPerformanceDataSize;
+  UINT8                                   *BootPerformanceData;
+  FIRMWARE_PERFORMANCE_VARIABLE           PerformanceVariable;
+  UINTN                                   SmmBootRecordDataSize;
+
+  SmmBootRecordDataSize = 0;
+
+  //
+  // Get SMM performance data size at the point of EndOfDxe in order to allocate the boot performance table.
+  // Will Get all the data at ReadyToBoot.
+  //
+  InternalGetSmmPerfData (NULL, &SmmBootRecordDataSize, TRUE);
 
   //
   // Prepare memory for Boot Performance table.
   // Boot Performance table includes BasicBoot record, and one or more appended Boot Records.
   //
-  BootPerformanceDataSize = sizeof (BOOT_PERFORMANCE_TABLE) + mPerformanceLength + PcdGet32 (PcdExtFpdtBootRecordPadSize);
-  if (SmmCommData != NULL && SmmBootRecordData != NULL) {
-    BootPerformanceDataSize += SmmBootRecordDataSize;
-  }
+  BootPerformanceDataSize = sizeof (BOOT_PERFORMANCE_TABLE) + mPerformanceLength + SmmBootRecordDataSize + PcdGet32 (PcdExtFpdtBootRecordPadSize);
 
   //
   // Try to allocate the same runtime buffer as last time boot.
   //
   ZeroMem (&PerformanceVariable, sizeof (PerformanceVariable));
@@ -356,13 +386,10 @@ AllocateBootPerformanceTable (
     }
   }
   DEBUG ((DEBUG_INFO, "DxeCorePerformanceLib: ACPI Boot Performance Table address = 0x%x\n", mAcpiBootPerformanceTable));
 
   if (mAcpiBootPerformanceTable == NULL) {
-    if (SmmCommData != NULL && SmmBootRecordData != NULL) {
-      FreePool (SmmBootRecordData);
-    }
     return EFI_OUT_OF_RESOURCES;
   }
 
   //
   // Prepare Boot Performance Table.
@@ -383,23 +410,14 @@ AllocateBootPerformanceTable (
     FreePool (mPerformancePointer);
     mPerformancePointer   = NULL;
     mPerformanceLength    = 0;
     mMaxPerformanceLength = 0;
   }
-  if (SmmCommData != NULL && SmmBootRecordData != NULL) {
-    //
-    // Fill Boot records from SMM drivers.
-    //
-    CopyMem (BootPerformanceData, SmmBootRecordData, SmmBootRecordDataSize);
-    FreePool (SmmBootRecordData);
-    mAcpiBootPerformanceTable->Header.Length = (UINT32) (mAcpiBootPerformanceTable->Header.Length + SmmBootRecordDataSize);
-    BootPerformanceData = BootPerformanceData + SmmBootRecordDataSize;
-  }
 
   mBootRecordBuffer  = (UINT8 *) mAcpiBootPerformanceTable;
   mBootRecordSize    = mAcpiBootPerformanceTable->Header.Length;
-  mBootRecordMaxSize = mBootRecordSize + PcdGet32 (PcdExtFpdtBootRecordPadSize);
+  mBootRecordMaxSize = BootPerformanceDataSize;
 
   return EFI_SUCCESS;
 }
 
 /**
@@ -1334,10 +1352,51 @@ ReportFpdtRecordBuffer (
     //
     mFpdtBufferIsReported = TRUE;
   }
 }
 
+/**
+  Update Boot Performance table.
+
+  @param  Event    The event of notify protocol.
+  @param  Context  Notify event context.
+
+**/
+VOID
+EFIAPI
+UpdateBootPerformanceTable (
+  IN EFI_EVENT     Event,
+  IN VOID          *Context
+  )
+{
+  VOID                             *SmmBootRecordData;
+  UINTN                            SmmBootRecordDataSize;
+  UINTN                            AppendSize;
+  UINT8                            *FirmwarePerformanceTablePtr;
+
+  //
+  // Get SMM performance data.
+  //
+  SmmBootRecordData = NULL;
+  InternalGetSmmPerfData (&SmmBootRecordData, &SmmBootRecordDataSize, FALSE);
+
+  FirmwarePerformanceTablePtr = (UINT8 *) mAcpiBootPerformanceTable + mAcpiBootPerformanceTable->Header.Length;
+
+  if (mAcpiBootPerformanceTable->Header.Length + SmmBootRecordDataSize > mBootRecordMaxSize) {
+    DEBUG ((DEBUG_INFO, "DxeCorePerformanceLib: No enough space to save all SMM boot performance data\n"));
+    AppendSize = mBootRecordMaxSize - mAcpiBootPerformanceTable->Header.Length;
+  } else {
+    AppendSize = SmmBootRecordDataSize;
+  }
+  if (SmmBootRecordData != NULL) {
+    CopyMem (FirmwarePerformanceTablePtr, SmmBootRecordData, AppendSize);
+    mAcpiBootPerformanceTable->Header.Length += (UINT32) AppendSize;
+    mBootRecordSize +=  (UINT32) AppendSize;
+    FreePool (SmmBootRecordData);
+  }
+}
+
 /**
   The constructor function initializes Performance infrastructure for DXE phase.
 
   The constructor function publishes Performance and PerformanceEx protocol, allocates memory to log DXE performance
   and merges PEI performance data to DXE performance log.
@@ -1356,10 +1415,11 @@ DxeCorePerformanceLibConstructor (
   IN EFI_SYSTEM_TABLE  *SystemTable
   )
 {
   EFI_STATUS                Status;
   EFI_HANDLE                Handle;
+  EFI_EVENT                 EndOfDxeEvent;
   EFI_EVENT                 ReadyToBootEvent;
   PERFORMANCE_PROPERTY      *PerformanceProperty;
 
   if (!PerformanceMeasurementEnabled ()) {
     //
@@ -1384,17 +1444,29 @@ DxeCorePerformanceLibConstructor (
                   NULL
                   );
   ASSERT_EFI_ERROR (Status);
 
   //
-  // Register ReadyToBoot event to report StatusCode data
+  // Register EndOfDxe event to allocate the boot performance table and report the table address through status code.
   //
   Status = gBS->CreateEventEx (
                   EVT_NOTIFY_SIGNAL,
-                  TPL_CALLBACK,
+                  TPL_NOTIFY,
                   ReportFpdtRecordBuffer,
                   NULL,
+                  &gEfiEndOfDxeEventGroupGuid,
+                  &EndOfDxeEvent
+                  );
+
+  //
+  // Register ReadyToBoot event to update the boot performance table for SMM performance data.
+  //
+  Status = gBS->CreateEventEx (
+                  EVT_NOTIFY_SIGNAL,
+                  TPL_CALLBACK,
+                  UpdateBootPerformanceTable,
+                  NULL,
                   &gEfiEventReadyToBootGuid,
                   &ReadyToBootEvent
                   );
 
   ASSERT_EFI_ERROR (Status);
diff --git a/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.inf b/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.inf
index 1c1dcc60a6..599d4dea66 100644
--- a/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.inf
+++ b/MdeModulePkg/Library/DxeCorePerformanceLib/DxeCorePerformanceLib.inf
@@ -7,11 +7,11 @@
 #  It initializes DXE phase performance logging by publishing the Performance and PerformanceEx Protocol,
 #  which is consumed by DxePerformanceLib to logging performance data in DXE phase.
 #  This library is mainly used by DxeCore to start performance logging to ensure that
 #  Performance and PerformanceEx Protocol are installed at the very beginning of DXE phase.
 #
-#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
 # (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
 #  SPDX-License-Identifier: BSD-2-Clause-Patent
 #
 ##
 
@@ -65,10 +65,11 @@
   ## PRODUCES             ## SystemTable
   gPerformanceProtocolGuid
   gZeroGuid                                     ## SOMETIMES_CONSUMES ## GUID
   gEfiFirmwarePerformanceGuid                   ## SOMETIMES_PRODUCES ## UNDEFINED # StatusCode Data
   gEdkiiFpdtExtendedFirmwarePerformanceGuid     ## SOMETIMES_CONSUMES ## HOB # StatusCode Data
+  gEfiEndOfDxeEventGroupGuid                    ## CONSUMES           ## Event
   gEfiEventReadyToBootGuid                      ## CONSUMES           ## Event
   gEdkiiPiSmmCommunicationRegionTableGuid       ## SOMETIMES_CONSUMES    ## SystemTable
   gEdkiiPerformanceMeasurementProtocolGuid      ## PRODUCES           ## UNDEFINED # Install protocol
 
 [Pcd]
diff --git a/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.c b/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.c
index b4f22c14ae..d80f37e520 100644
--- a/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.c
+++ b/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.c
@@ -14,11 +14,11 @@
  This external input must be validated carefully to avoid security issue like
  buffer overflow, integer overflow.
 
  SmmPerformanceHandlerEx(), SmmPerformanceHandler() will receive untrusted input and do basic validation.
 
-Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
 SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 
@@ -46,10 +46,11 @@ BOOLEAN              mFpdtDataIsReported   = FALSE;
 BOOLEAN              mLackSpaceIsReport    = FALSE;
 CHAR8                *mPlatformLanguage    = NULL;
 SPIN_LOCK            mSmmFpdtLock;
 PERFORMANCE_PROPERTY  mPerformanceProperty;
 UINT32               mCachedLength         = 0;
+UINT32               mBootRecordSize       = 0;
 
 //
 // Interfaces for SMM PerformanceMeasurement Protocol.
 //
 EDKII_PERFORMANCE_MEASUREMENT_PROTOCOL mPerformanceMeasurementInterface = {
@@ -774,45 +775,120 @@ InsertFpdtRecord (
 
   return EFI_SUCCESS;
 }
 
 /**
-  SmmReadyToBoot protocol notification event handler.
+  Communication service SMI Handler entry.
 
-  @param  Protocol   Points to the protocol's unique identifier
-  @param  Interface  Points to the interface instance
-  @param  Handle     The handle on which the interface was installed
+  This SMI handler provides services for report MM boot records.
 
-  @retval EFI_SUCCESS   SmmReadyToBootCallback runs successfully
+  Caution: This function may receive untrusted input.
+  Communicate buffer and buffer size are external input, so this function will do basic validation.
+
+  @param[in]     DispatchHandle  The unique handle assigned to this handler by SmiHandlerRegister().
+  @param[in]     RegisterContext Points to an optional handler context which was specified when the
+                                 handler was registered.
+  @param[in, out] CommBuffer     A pointer to a collection of data in memory that will
+                                 be conveyed from a non-MM environment into an MM environment.
+  @param[in, out] CommBufferSize The size of the CommBuffer.
+
+  @retval EFI_SUCCESS                         The interrupt was handled and quiesced. No other handlers
+                                              should still be called.
+  @retval EFI_WARN_INTERRUPT_SOURCE_QUIESCED  The interrupt has been quiesced but other handlers should
+                                              still be called.
+  @retval EFI_WARN_INTERRUPT_SOURCE_PENDING   The interrupt is still pending and other handlers should still
+                                              be called.
+  @retval EFI_INTERRUPT_PENDING               The interrupt could not be quiesced.
 
 **/
 EFI_STATUS
 EFIAPI
-SmmReportFpdtRecordData (
-  IN CONST EFI_GUID                       *Protocol,
-  IN VOID                                 *Interface,
-  IN EFI_HANDLE                           Handle
+FpdtSmiHandler (
+  IN     EFI_HANDLE                   DispatchHandle,
+  IN     CONST VOID                   *RegisterContext,
+  IN OUT VOID                         *CommBuffer,
+  IN OUT UINTN                        *CommBufferSize
   )
 {
-  UINT64          SmmBPDTddr;
-
-  if (!mFpdtDataIsReported && mSmmBootPerformanceTable != NULL) {
-    SmmBPDTddr = (UINT64)(UINTN)mSmmBootPerformanceTable;
-    REPORT_STATUS_CODE_EX (
-        EFI_PROGRESS_CODE,
-        EFI_SOFTWARE_SMM_DRIVER,
-        0,
-        NULL,
-        &gEdkiiFpdtExtendedFirmwarePerformanceGuid,
-        &SmmBPDTddr,
-        sizeof (UINT64)
+  EFI_STATUS                   Status;
+  SMM_BOOT_RECORD_COMMUNICATE  *SmmCommData;
+  UINTN                        BootRecordOffset;
+  UINTN                        BootRecordSize;
+  VOID                         *BootRecordData;
+  UINTN                        TempCommBufferSize;
+  UINT8                        *BootRecordBuffer;
+
+  //
+  // If input is invalid, stop processing this SMI
+  //
+  if (CommBuffer == NULL || CommBufferSize == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  TempCommBufferSize = *CommBufferSize;
+
+  if(TempCommBufferSize < sizeof (SMM_BOOT_RECORD_COMMUNICATE)) {
+    return EFI_SUCCESS;
+  }
+
+  if (!SmmIsBufferOutsideSmmValid ((UINTN)CommBuffer, TempCommBufferSize)) {
+    DEBUG ((DEBUG_ERROR, "FpdtSmiHandler: MM communication data buffer in MMRAM or overflow!\n"));
+    return EFI_SUCCESS;
+  }
+
+  SmmCommData = (SMM_BOOT_RECORD_COMMUNICATE*)CommBuffer;
+
+  Status = EFI_SUCCESS;
+
+  switch (SmmCommData->Function) {
+    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_SIZE :
+      if (mSmmBootPerformanceTable != NULL) {
+        mBootRecordSize = mSmmBootPerformanceTable->Header.Length - sizeof (SMM_BOOT_PERFORMANCE_TABLE);
+      }
+      SmmCommData->BootRecordSize = mBootRecordSize;
+      break;
+
+    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_DATA :
+      Status = EFI_UNSUPPORTED;
+      break;
+
+    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_DATA_BY_OFFSET :
+      BootRecordOffset = SmmCommData->BootRecordOffset;
+      BootRecordData   = SmmCommData->BootRecordData;
+      BootRecordSize   = SmmCommData->BootRecordSize;
+      if (BootRecordData == NULL || BootRecordOffset >= mBootRecordSize) {
+        Status = EFI_INVALID_PARAMETER;
+        break;
+      }
+
+      //
+      // Sanity check
+      //
+      if (BootRecordSize > mBootRecordSize - BootRecordOffset) {
+        BootRecordSize = mBootRecordSize - BootRecordOffset;
+      }
+      SmmCommData->BootRecordSize = BootRecordSize;
+      if (!SmmIsBufferOutsideSmmValid ((UINTN)BootRecordData, BootRecordSize)) {
+        DEBUG ((DEBUG_ERROR, "FpdtSmiHandler: MM Data buffer in MMRAM or overflow!\n"));
+        Status = EFI_ACCESS_DENIED;
+        break;
+      }
+      BootRecordBuffer = ((UINT8 *) (mSmmBootPerformanceTable)) + sizeof (SMM_BOOT_PERFORMANCE_TABLE);
+      CopyMem (
+        (UINT8*)BootRecordData,
+        BootRecordBuffer + BootRecordOffset,
+        BootRecordSize
         );
-    //
-    // Set FPDT report state to TRUE.
-    //
-    mFpdtDataIsReported = TRUE;
+      mFpdtDataIsReported = TRUE;
+      break;
+
+    default:
+      Status = EFI_UNSUPPORTED;
   }
+
+  SmmCommData->ReturnStatus = Status;
+
   return EFI_SUCCESS;
 }
 
 /**
   SmmBase2 protocol notify callback function, when SMST and SMM memory service get initialized
@@ -828,12 +904,12 @@ InitializeSmmCorePerformanceLib (
   IN EFI_EVENT     Event,
   IN VOID          *Context
   )
 {
   EFI_HANDLE                Handle;
+  EFI_HANDLE                SmiHandle;
   EFI_STATUS                Status;
-  VOID                      *SmmReadyToBootRegistration;
   PERFORMANCE_PROPERTY      *PerformanceProperty;
 
   //
   // Initialize spin lock
   //
@@ -849,15 +925,17 @@ InitializeSmmCorePerformanceLib (
                     EFI_NATIVE_INTERFACE,
                     &mPerformanceMeasurementInterface
                     );
   ASSERT_EFI_ERROR (Status);
 
-  Status = gSmst->SmmRegisterProtocolNotify (
-                    &gEdkiiSmmReadyToBootProtocolGuid,
-                    SmmReportFpdtRecordData,
-                    &SmmReadyToBootRegistration
-                    );
+  //
+  // Register SMI handler.
+  //
+  SmiHandle = NULL;
+  Status = gSmst->SmiHandlerRegister (FpdtSmiHandler, &gEfiFirmwarePerformanceGuid, &SmiHandle);
+  ASSERT_EFI_ERROR (Status);
+
   Status = EfiGetSystemConfigurationTable (&gPerformanceProtocolGuid, (VOID **) &PerformanceProperty);
   if (EFI_ERROR (Status)) {
     //
     // Install configuration table for performance property.
     //
diff --git a/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.inf b/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.inf
index 6b013b8557..9eecc4b58c 100644
--- a/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.inf
+++ b/MdeModulePkg/Library/SmmCorePerformanceLib/SmmCorePerformanceLib.inf
@@ -6,11 +6,11 @@
 #  It initializes SMM phase performance logging by publishing the SMM Performance and PerformanceEx Protocol,
 #  which is consumed by SmmPerformanceLib to logging performance data in SMM phase.
 #  This library is mainly used by SMM Core to start performance logging to ensure that
 #  SMM Performance and PerformanceEx Protocol are installed at the very beginning of SMM phase.
 #
-#  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
 #  SPDX-License-Identifier: BSD-2-Clause-Patent
 #
 ##
 
 [Defines]
@@ -56,17 +56,16 @@
   PeCoffGetEntryPointLib
   DxeServicesLib
 
 [Protocols]
   gEfiSmmBase2ProtocolGuid                  ## CONSUMES
-  gEdkiiSmmReadyToBootProtocolGuid          ## NOTIFY
 
 [Guids]
   ## PRODUCES ## SystemTable
   gPerformanceProtocolGuid
-  gEdkiiFpdtExtendedFirmwarePerformanceGuid ## SOMETIMES_PRODUCES ## UNDEFINED # StatusCode Data
   gZeroGuid                                 ## SOMETIMES_CONSUMES ## GUID
   gEdkiiSmmPerformanceMeasurementProtocolGuid             ## PRODUCES ## UNDEFINED # Install protocol
+  gEfiFirmwarePerformanceGuid               ## SOMETIMES_PRODUCES ## UNDEFINED # SmiHandlerRegister
 
 [Pcd]
   gEfiMdePkgTokenSpaceGuid.PcdPerformanceLibraryPropertyMask        ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdEdkiiFpdtStringRecordEnableOnly ## CONSUMES
diff --git a/MdeModulePkg/MdeModulePkg.dec b/MdeModulePkg/MdeModulePkg.dec
index ad84421cf3..6002e4c71a 100644
--- a/MdeModulePkg/MdeModulePkg.dec
+++ b/MdeModulePkg/MdeModulePkg.dec
@@ -1868,13 +1868,13 @@
   #  BIT1 set indicates 64-bit entry point and table are produced.<BR>
   # @Prompt The policy to produce SMBIOS entry point and table.
   gEfiMdeModulePkgTokenSpaceGuid.PcdSmbiosEntryPointProvideMethod|0x3|UINT32|0x00010069
 
   ## This PCD specifies the additional pad size in FPDT Basic Boot Performance Table for
-  #  the extension FPDT boot records received after ReadyToBoot and before ExitBootService.
+  #  the extension FPDT boot records received after EndOfDxe and before ExitBootService.
   # @Prompt Pad size for extension FPDT boot records.
-  gEfiMdeModulePkgTokenSpaceGuid.PcdExtFpdtBootRecordPadSize|0x20000|UINT32|0x0001005F
+  gEfiMdeModulePkgTokenSpaceGuid.PcdExtFpdtBootRecordPadSize|0x30000|UINT32|0x0001005F
 
   ## Indicates if ConIn device are connected on demand.<BR><BR>
   #   TRUE  - ConIn device are not connected during BDS and ReadKeyStroke/ReadKeyStrokeEx produced
   #           by Consplitter should be called before any real key read operation.<BR>
   #   FALSE - ConIn device may be connected normally during BDS.<BR>
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.c b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.c
index 61a7704b37..a6a0cd9e7d 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.c
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.c
@@ -3,21 +3,22 @@
 
   This module register report status code listener to collect performance data
   for Firmware Basic Boot Performance Record and other boot performance records,
   and install FPDT to ACPI table.
 
-  Copyright (c) 2011 - 2019, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
   SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 #include <PiDxe.h>
 
 #include <Protocol/ReportStatusCodeHandler.h>
 #include <Protocol/AcpiTable.h>
 #include <Protocol/LockBox.h>
 #include <Protocol/Variable.h>
+#include <Protocol/VariablePolicy.h>
 
 #include <Guid/Acpi.h>
 #include <Guid/FirmwarePerformance.h>
 
 #include <Library/UefiBootServicesTableLib.h>
@@ -30,10 +31,12 @@
 #include <Library/MemoryAllocationLib.h>
 #include <Library/PcdLib.h>
 #include <Library/HobLib.h>
 #include <Library/LockBoxLib.h>
 #include <Library/UefiLib.h>
+#include <Library/VariablePolicyHelperLib.h>
+#include <Library/PerformanceLib.h>
 
 #define SMM_BOOT_RECORD_COMM_SIZE (OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + sizeof(SMM_BOOT_RECORD_COMMUNICATE))
 
 EFI_RSC_HANDLER_PROTOCOL    *mRscHandlerProtocol = NULL;
 
@@ -276,24 +279,33 @@ FpdtAllocateS3PerformanceTableMemory (
 EFI_STATUS
 InstallFirmwarePerformanceDataTable (
   VOID
   )
 {
-  EFI_STATUS                    Status;
-  EFI_ACPI_TABLE_PROTOCOL       *AcpiTableProtocol;
-  UINTN                         BootPerformanceDataSize;
-  FIRMWARE_PERFORMANCE_VARIABLE PerformanceVariable;
-  UINTN                         Size;
+  EFI_STATUS                      Status;
+  EFI_ACPI_TABLE_PROTOCOL         *AcpiTableProtocol;
+  UINTN                           BootPerformanceDataSize;
+  FIRMWARE_PERFORMANCE_VARIABLE   PerformanceVariable;
+  UINTN                           Size;
+  EDKII_VARIABLE_POLICY_PROTOCOL  *VariablePolicyProtocol;
 
   //
   // Get AcpiTable Protocol.
   //
   Status = gBS->LocateProtocol (&gEfiAcpiTableProtocolGuid, NULL, (VOID **) &AcpiTableProtocol);
   if (EFI_ERROR (Status)) {
     return Status;
   }
 
+  //
+  // Get VariablePolicy Protocol.
+  //
+  Status = gBS->LocateProtocol(&gEdkiiVariablePolicyProtocolGuid, NULL, (VOID **)&VariablePolicyProtocol);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
   if (mReceivedAcpiBootPerformanceTable != NULL) {
     mAcpiBootPerformanceTable = mReceivedAcpiBootPerformanceTable;
     mAcpiBootPerformanceTable->BasicBoot.ResetEnd = mBootPerformanceTableTemplate.BasicBoot.ResetEnd;
   } else {
     //
@@ -367,10 +379,28 @@ InstallFirmwarePerformanceDataTable (
         EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
         sizeof (PerformanceVariable),
         &PerformanceVariable
         );
 
+  //
+  // Lock the variable which stores the Performance Table pointers.
+  //
+  Status = RegisterBasicVariablePolicy (
+             VariablePolicyProtocol,
+             &gEfiFirmwarePerformanceGuid,
+             EFI_FIRMWARE_PERFORMANCE_VARIABLE_NAME,
+             VARIABLE_POLICY_NO_MIN_SIZE,
+             VARIABLE_POLICY_NO_MAX_SIZE,
+             VARIABLE_POLICY_NO_MUST_ATTR,
+             VARIABLE_POLICY_NO_CANT_ATTR,
+             VARIABLE_POLICY_TYPE_LOCK_NOW
+             );
+  if (EFI_ERROR(Status)) {
+    DEBUG((EFI_D_ERROR, "[FirmwarePerformanceDxe] Error when lock variable %s, Status = %r\n", EFI_FIRMWARE_PERFORMANCE_VARIABLE_NAME, Status));
+    ASSERT_EFI_ERROR(Status);
+  }
+
   //
   // Publish Firmware Performance Data Table.
   //
   FpdtAcpiTableChecksum ((UINT8 *) &mFirmwarePerformanceTableTemplate, mFirmwarePerformanceTableTemplate.Header.Length);
   Status = AcpiTableProtocol->InstallAcpiTable (
@@ -499,22 +529,16 @@ FpdtStatusCodeListenerDxe (
     DEBUG ((EFI_D_INFO, "FPDT: Boot Performance - ResetEnd                = %ld\n", mAcpiBootPerformanceTable->BasicBoot.ResetEnd));
     DEBUG ((EFI_D_INFO, "FPDT: Boot Performance - OsLoaderLoadImageStart  = 0\n"));
     DEBUG ((EFI_D_INFO, "FPDT: Boot Performance - OsLoaderStartImageStart = %ld\n", mAcpiBootPerformanceTable->BasicBoot.OsLoaderStartImageStart));
     DEBUG ((EFI_D_INFO, "FPDT: Boot Performance - ExitBootServicesEntry   = 0\n"));
     DEBUG ((EFI_D_INFO, "FPDT: Boot Performance - ExitBootServicesExit    = 0\n"));
-  } else if (Value == (EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_DXE_BS_PC_READY_TO_BOOT_EVENT)) {
-    if (mAcpiBootPerformanceTable == NULL) {
-      //
-      // ACPI Firmware Performance Data Table not installed yet, install it now.
-      //
-      InstallFirmwarePerformanceDataTable ();
-    }
   } else if (Data != NULL && CompareGuid (&Data->Type, &gEdkiiFpdtExtendedFirmwarePerformanceGuid)) {
     //
     // Get the Boot performance table and then install it to ACPI table.
     //
     CopyMem (&mReceivedAcpiBootPerformanceTable, Data + 1, Data->Size);
+    InstallFirmwarePerformanceDataTable ();
   } else if (Data != NULL && CompareGuid (&Data->Type, &gEfiFirmwarePerformanceGuid)) {
     DEBUG ((DEBUG_ERROR, "FpdtStatusCodeListenerDxe: Performance data reported through gEfiFirmwarePerformanceGuid will not be collected by FirmwarePerformanceDataTableDxe\n"));
     Status = EFI_UNSUPPORTED;
   } else {
     //
@@ -524,10 +548,36 @@ FpdtStatusCodeListenerDxe (
   }
 
   return Status;
 }
 
+/**
+  Notify function for event EndOfDxe.
+
+  This is used to install ACPI Firmware Performance Data Table for basic boot records.
+
+  @param[in]  Event   The Event that is being processed.
+  @param[in]  Context The Event Context.
+
+**/
+VOID
+EFIAPI
+FpdtEndOfDxeEventNotify (
+  IN EFI_EVENT        Event,
+  IN VOID             *Context
+  )
+{
+  //
+  // When performance is enabled, the FPDT will be installed when DxeCorePerformanceLib report the data to FimwarePerformanceDxe.
+  // This is used to install the FPDT for the basic boot recods when performance infrastructure is not enabled.
+  //
+  if ((PcdGet8(PcdPerformanceLibraryPropertyMask) & PERFORMANCE_LIBRARY_PROPERTY_MEASUREMENT_ENABLED) != 0) {
+    return;
+  }
+  ASSERT (mReceivedAcpiBootPerformanceTable == NULL);
+  InstallFirmwarePerformanceDataTable ();
+}
 
 /**
   Notify function for event EVT_SIGNAL_EXIT_BOOT_SERVICES. This is used to record
   performance data for ExitBootServicesEntry in FPDT.
 
@@ -594,10 +644,11 @@ FirmwarePerformanceDxeEntryPoint (
   EFI_STATUS               Status;
   EFI_HOB_GUID_TYPE        *GuidHob;
   FIRMWARE_SEC_PERFORMANCE *Performance;
   VOID                     *Registration;
   UINT64                   OemTableId;
+  EFI_EVENT                EndOfDxeEvent;
 
   CopyMem (
     mFirmwarePerformanceTableTemplate.Header.OemId,
     PcdGetPtr (PcdAcpiDefaultOemId),
     sizeof (mFirmwarePerformanceTableTemplate.Header.OemId)
@@ -618,10 +669,23 @@ FirmwarePerformanceDxeEntryPoint (
   // Register report status code listener for OS Loader load and start.
   //
   Status = mRscHandlerProtocol->Register (FpdtStatusCodeListenerDxe, TPL_HIGH_LEVEL);
   ASSERT_EFI_ERROR (Status);
 
+  //
+  // Register the notify function to install FPDT at EndOfDxe.
+  //
+  Status = gBS->CreateEventEx (
+                  EVT_NOTIFY_SIGNAL,
+                  TPL_NOTIFY,
+                  FpdtEndOfDxeEventNotify,
+                  NULL,
+                  &gEfiEndOfDxeEventGroupGuid,
+                  &EndOfDxeEvent
+                  );
+  ASSERT_EFI_ERROR (Status);
+
   //
   // Register the notify function to update FPDT on ExitBootServices Event.
   //
   Status = gBS->CreateEventEx (
                   EVT_NOTIFY_SIGNAL,
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.inf b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.inf
index 1debb0193e..0411a22e66 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.inf
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableDxe/FirmwarePerformanceDxe.inf
@@ -3,11 +3,11 @@
 #
 #  This module registers report status code listener to collect performance data
 #  for Firmware Basic Boot Performance Record and other boot performance records,
 #  and install FPDT to ACPI table.
 #
-#  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
 #  SPDX-License-Identifier: BSD-2-Clause-Patent
 #
 ##
 
 [Defines]
@@ -44,16 +44,18 @@
   MemoryAllocationLib
   PcdLib
   HobLib
   LockBoxLib
   UefiLib
+  VariablePolicyHelperLib
 
 [Protocols]
   gEfiAcpiTableProtocolGuid                     ## CONSUMES
   gEfiRscHandlerProtocolGuid                    ## CONSUMES
   gEfiVariableArchProtocolGuid                  ## CONSUMES
   gEfiLockBoxProtocolGuid                       ## CONSUMES
+  gEdkiiVariablePolicyProtocolGuid              ## CONSUMES
 
 [Guids]
   gEfiEventExitBootServicesGuid                 ## CONSUMES             ## Event
   ## SOMETIMES_CONSUMES   ## HOB
   ## SOMETIMES_CONSUMES   ## Variable:L"FirmwarePerformance"
@@ -61,19 +63,21 @@
   ## SOMETIMES_CONSUMES ## UNDEFINED # Used to do smm communication
   ## SOMETIMES_CONSUMES ## UNDEFINED # StatusCode Data
   gEfiFirmwarePerformanceGuid
   gEdkiiFpdtExtendedFirmwarePerformanceGuid     ## SOMETIMES_CONSUMES ## UNDEFINED # StatusCode Data
   gFirmwarePerformanceS3PointerGuid             ## PRODUCES ## UNDEFINED # SaveLockBox
+  gEfiEndOfDxeEventGroupGuid                    ## CONSUMES ## Event
 
 [Pcd]
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeOsLoaderLoad    ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeOsLoaderStart   ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId            ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId       ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision      ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId        ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision  ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdPerformanceLibraryPropertyMask    ## CONSUMES
 
 [FeaturePcd]
   gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwarePerformanceDataTableS3Support   ## CONSUMES
 
 [Depex]
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.c b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.c
index ecadef8711..47db9a2fc0 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.c
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.c
@@ -9,11 +9,11 @@
   This external input must be validated carefully to avoid security issue like
   buffer overflow, integer overflow.
 
   FpdtSmiHandler() will receive untrusted input and do basic validation.
 
-  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
   SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 #include <PiMm.h>
@@ -27,24 +27,16 @@
 #include <Library/DebugLib.h>
 #include <Library/TimerLib.h>
 #include <Library/LockBoxLib.h>
 #include <Library/PcdLib.h>
 #include <Library/BaseMemoryLib.h>
-#include <Library/MemoryAllocationLib.h>
-#include <Library/SynchronizationLib.h>
 #include "FirmwarePerformanceCommon.h"
 
-SMM_BOOT_PERFORMANCE_TABLE    *mMmBootPerformanceTable = NULL;
 
 EFI_MM_RSC_HANDLER_PROTOCOL   *mRscHandlerProtocol    = NULL;
 UINT64                        mSuspendStartTime       = 0;
 BOOLEAN                       mS3SuspendLockBoxSaved  = FALSE;
-UINT32                        mBootRecordSize = 0;
-UINT8                         *mBootRecordBuffer = NULL;
-
-SPIN_LOCK                     mMmFpdtLock;
-BOOLEAN                       mMmramIsOutOfResource = FALSE;
 
 /**
   Report status code listener for MM. This is used to record the performance
   data for S3 Suspend Start and S3 Suspend End in FPDT.
 
@@ -82,25 +74,10 @@ FpdtStatusCodeListenerMm (
   //
   if ((CodeType & EFI_STATUS_CODE_TYPE_MASK) != EFI_PROGRESS_CODE) {
     return EFI_UNSUPPORTED;
   }
 
-  //
-  // Collect one or more Boot records in boot time
-  //
-  if (Data != NULL && CompareGuid (&Data->Type, &gEdkiiFpdtExtendedFirmwarePerformanceGuid)) {
-    AcquireSpinLock (&mMmFpdtLock);
-    //
-    // Get the boot performance data.
-    //
-    CopyMem (&mMmBootPerformanceTable, Data + 1, Data->Size);
-    mBootRecordBuffer = ((UINT8 *) (mMmBootPerformanceTable)) + sizeof (SMM_BOOT_PERFORMANCE_TABLE);
-
-    ReleaseSpinLock (&mMmFpdtLock);
-    return EFI_SUCCESS;
-  }
-
   if (Data != NULL && CompareGuid (&Data->Type, &gEfiFirmwarePerformanceGuid)) {
     DEBUG ((DEBUG_ERROR, "FpdtStatusCodeListenerMm: Performance data reported through gEfiFirmwarePerformanceGuid will not be collected by FirmwarePerformanceDataTableMm\n"));
     return EFI_UNSUPPORTED;
   }
 
@@ -151,122 +128,10 @@ FpdtStatusCodeListenerMm (
   }
 
   return EFI_SUCCESS;
 }
 
-/**
-  Communication service SMI Handler entry.
-
-  This SMI handler provides services for report MM boot records.
-
-  Caution: This function may receive untrusted input.
-  Communicate buffer and buffer size are external input, so this function will do basic validation.
-
-  @param[in]     DispatchHandle  The unique handle assigned to this handler by SmiHandlerRegister().
-  @param[in]     RegisterContext Points to an optional handler context which was specified when the
-                                 handler was registered.
-  @param[in, out] CommBuffer     A pointer to a collection of data in memory that will
-                                 be conveyed from a non-MM environment into an MM environment.
-  @param[in, out] CommBufferSize The size of the CommBuffer.
-
-  @retval EFI_SUCCESS                         The interrupt was handled and quiesced. No other handlers
-                                              should still be called.
-  @retval EFI_WARN_INTERRUPT_SOURCE_QUIESCED  The interrupt has been quiesced but other handlers should
-                                              still be called.
-  @retval EFI_WARN_INTERRUPT_SOURCE_PENDING   The interrupt is still pending and other handlers should still
-                                              be called.
-  @retval EFI_INTERRUPT_PENDING               The interrupt could not be quiesced.
-
-**/
-EFI_STATUS
-EFIAPI
-FpdtSmiHandler (
-  IN     EFI_HANDLE                   DispatchHandle,
-  IN     CONST VOID                   *RegisterContext,
-  IN OUT VOID                         *CommBuffer,
-  IN OUT UINTN                        *CommBufferSize
-  )
-{
-  EFI_STATUS                   Status;
-  SMM_BOOT_RECORD_COMMUNICATE  *SmmCommData;
-  UINTN                        BootRecordOffset;
-  UINTN                        BootRecordSize;
-  VOID                         *BootRecordData;
-  UINTN                        TempCommBufferSize;
-
-  //
-  // If input is invalid, stop processing this SMI
-  //
-  if (CommBuffer == NULL || CommBufferSize == NULL) {
-    return EFI_SUCCESS;
-  }
-
-  TempCommBufferSize = *CommBufferSize;
-
-  if(TempCommBufferSize < sizeof (SMM_BOOT_RECORD_COMMUNICATE)) {
-    return EFI_SUCCESS;
-  }
-
-  if (!IsBufferOutsideMmValid ((UINTN)CommBuffer, TempCommBufferSize)) {
-    DEBUG ((DEBUG_ERROR, "FpdtSmiHandler: MM communication data buffer in MMRAM or overflow!\n"));
-    return EFI_SUCCESS;
-  }
-
-  SmmCommData = (SMM_BOOT_RECORD_COMMUNICATE*)CommBuffer;
-
-  Status = EFI_SUCCESS;
-
-  switch (SmmCommData->Function) {
-    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_SIZE :
-      if (mMmBootPerformanceTable != NULL) {
-        mBootRecordSize = mMmBootPerformanceTable->Header.Length - sizeof (SMM_BOOT_PERFORMANCE_TABLE);
-      }
-      SmmCommData->BootRecordSize = mBootRecordSize;
-      break;
-
-    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_DATA :
-      Status = EFI_UNSUPPORTED;
-      break;
-
-    case SMM_FPDT_FUNCTION_GET_BOOT_RECORD_DATA_BY_OFFSET :
-      BootRecordOffset = SmmCommData->BootRecordOffset;
-      BootRecordData   = SmmCommData->BootRecordData;
-      BootRecordSize   = SmmCommData->BootRecordSize;
-      if (BootRecordData == NULL || BootRecordOffset >= mBootRecordSize) {
-        Status = EFI_INVALID_PARAMETER;
-        break;
-      }
-
-      //
-      // Sanity check
-      //
-      if (BootRecordSize > mBootRecordSize - BootRecordOffset) {
-        BootRecordSize = mBootRecordSize - BootRecordOffset;
-      }
-      SmmCommData->BootRecordSize = BootRecordSize;
-      if (!IsBufferOutsideMmValid ((UINTN)BootRecordData, BootRecordSize)) {
-        DEBUG ((DEBUG_ERROR, "FpdtSmiHandler: MM Data buffer in MMRAM or overflow!\n"));
-        Status = EFI_ACCESS_DENIED;
-        break;
-      }
-
-      CopyMem (
-       (UINT8*)BootRecordData,
-       mBootRecordBuffer + BootRecordOffset,
-       BootRecordSize
-       );
-      break;
-
-    default:
-      Status = EFI_UNSUPPORTED;
-  }
-
-  SmmCommData->ReturnStatus = Status;
-
-  return EFI_SUCCESS;
-}
-
 /**
   The module Entry Point of the Firmware Performance Data Table MM driver.
 
   @retval EFI_SUCCESS    The entry point is executed successfully.
   @retval Other          Some error occurs when executing this entry point.
@@ -276,16 +141,10 @@ EFI_STATUS
 FirmwarePerformanceCommonEntryPoint (
   VOID
   )
 {
   EFI_STATUS                Status;
-  EFI_HANDLE                Handle;
-
-  //
-  // Initialize spin lock
-  //
-  InitializeSpinLock (&mMmFpdtLock);
 
   //
   // Get MM Report Status Code Handler Protocol.
   //
   Status = gMmst->MmLocateProtocol (
@@ -299,14 +158,7 @@ FirmwarePerformanceCommonEntryPoint (
   // Register report status code listener for BootRecords and S3 Suspend Start and End.
   //
   Status = mRscHandlerProtocol->Register (FpdtStatusCodeListenerMm);
   ASSERT_EFI_ERROR (Status);
 
-  //
-  // Register SMI handler.
-  //
-  Handle = NULL;
-  Status = gMmst->MmiHandlerRegister (FpdtSmiHandler, &gEfiFirmwarePerformanceGuid, &Handle);
-  ASSERT_EFI_ERROR (Status);
-
   return Status;
 }
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.h b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.h
index 0fbdac02de..0640c48db7 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.h
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceCommon.h
@@ -9,34 +9,19 @@
   This external input must be validated carefully to avoid security issue like
   buffer overflow, integer overflow.
 
   FpdtSmiHandler() will receive untrusted input and do basic validation.
 
-  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
   Copyright (c), Microsoft Corporation.
   SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 #ifndef _FW_PERF_COMMON_H_
 #define _FW_PERF_COMMON_H_
 
-/**
-  This function is an abstraction layer for implementation specific Mm buffer validation routine.
-
-  @param Buffer  The buffer start address to be checked.
-  @param Length  The buffer length to be checked.
-
-  @retval TRUE  This buffer is valid per processor architecture and not overlap with SMRAM.
-  @retval FALSE This buffer is not valid per processor architecture or overlap with SMRAM.
-**/
-BOOLEAN
-IsBufferOutsideMmValid (
-  IN EFI_PHYSICAL_ADDRESS  Buffer,
-  IN UINT64                Length
-  );
-
 /**
   The module Entry Point of the Firmware Performance Data Table MM driver.
 
   @retval EFI_SUCCESS    The entry point is executed successfully.
   @retval Other          Some error occurs when executing this entry point.
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf
index b7194bd899..a4da0ba8b2 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf
@@ -2,11 +2,11 @@
 #  This module collects performance data for SMM driver boot records and S3 Suspend Performance Record.
 #
 #  This module registers report status code listener to collect performance data
 #  for SMM boot performance records and S3 Suspend Performance Record.
 #
-#  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
 #  SPDX-License-Identifier: BSD-2-Clause-Patent
 #
 ##
 
 [Defines]
@@ -50,14 +50,12 @@
 [Protocols]
   gEfiMmRscHandlerProtocolGuid                 ## CONSUMES
 
 [Guids]
   ## SOMETIMES_PRODUCES   ## UNDEFINED # SaveLockBox
-  ## PRODUCES             ## UNDEFINED # SmiHandlerRegister
   ## SOMETIMES_CONSUMES   ## UNDEFINED # StatusCode Data
   gEfiFirmwarePerformanceGuid
-  gEdkiiFpdtExtendedFirmwarePerformanceGuid  ## SOMETIMES_PRODUCES ## UNDEFINED # StatusCode Data
 
 [Pcd]
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeS3SuspendStart  ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeS3SuspendEnd    ## CONSUMES
 
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.c b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.c
index d7da61c98c..be52d8ce90 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.c
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.c
@@ -9,39 +9,20 @@
   This external input must be validated carefully to avoid security issue like
   buffer overflow, integer overflow.
 
   FpdtSmiHandler() will receive untrusted input and do basic validation.
 
-  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
   Copyright (c), Microsoft Corporation.
   SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 #include <PiMm.h>
 
-#include <Library/StandaloneMmMemLib.h>
 #include "FirmwarePerformanceCommon.h"
 
-/**
-  This function is an abstraction layer for implementation specific Mm buffer validation routine.
-
-  @param Buffer  The buffer start address to be checked.
-  @param Length  The buffer length to be checked.
-
-  @retval TRUE  This buffer is valid per processor architecture and not overlap with SMRAM.
-  @retval FALSE This buffer is not valid per processor architecture or overlap with SMRAM.
-**/
-BOOLEAN
-IsBufferOutsideMmValid (
-  IN EFI_PHYSICAL_ADDRESS  Buffer,
-  IN UINT64                Length
-  )
-{
-  return MmIsBufferOutsideMmValid (Buffer, Length);
-}
-
 /**
   The module Entry Point of the Firmware Performance Data Table MM driver.
 
   @param[in]  ImageHandle    The firmware allocated handle for the EFI image.
   @param[in]  SystemTable    A pointer to the EFI MM System Table.
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf
index e6aad88be0..fabe30b071 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf
@@ -2,11 +2,11 @@
 #  This module collects performance data for SMM driver boot records and S3 Suspend Performance Record.
 #
 #  This module registers report status code listener to collect performance data
 #  for SMM boot performance records and S3 Suspend Performance Record.
 #
-#  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
 #  Copyright (c) Microsoft Corporation.
 #  SPDX-License-Identifier: BSD-2-Clause-Patent
 #
 ##
 
@@ -51,14 +51,12 @@
 [Protocols]
   gEfiMmRscHandlerProtocolGuid                 ## CONSUMES
 
 [Guids]
   ## SOMETIMES_PRODUCES   ## UNDEFINED # SaveLockBox
-  ## PRODUCES             ## UNDEFINED # SmiHandlerRegister
   ## SOMETIMES_CONSUMES   ## UNDEFINED # StatusCode Data
   gEfiFirmwarePerformanceGuid
-  gEdkiiFpdtExtendedFirmwarePerformanceGuid  ## SOMETIMES_PRODUCES ## UNDEFINED # StatusCode Data
 
 [Pcd]
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeS3SuspendStart  ## CONSUMES
   gEfiMdeModulePkgTokenSpaceGuid.PcdProgressCodeS3SuspendEnd    ## CONSUMES
 
diff --git a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceTraditional.c b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceTraditional.c
index 43c050d6b5..5bd38b0ef3 100644
--- a/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceTraditional.c
+++ b/MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceTraditional.c
@@ -9,39 +9,20 @@
   This external input must be validated carefully to avoid security issue like
   buffer overflow, integer overflow.
 
   FpdtSmiHandler() will receive untrusted input and do basic validation.
 
-  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011 - 2021, Intel Corporation. All rights reserved.<BR>
   Copyright (c), Microsoft Corporation.
   SPDX-License-Identifier: BSD-2-Clause-Patent
 
 **/
 
 #include <PiSmm.h>
 
-#include <Library/SmmMemLib.h>
 #include "FirmwarePerformanceCommon.h"
 
-/**
-  This function is an abstraction layer for implementation specific Mm buffer validation routine.
-
-  @param Buffer  The buffer start address to be checked.
-  @param Length  The buffer length to be checked.
-
-  @retval TRUE  This buffer is valid per processor architecture and not overlap with SMRAM.
-  @retval FALSE This buffer is not valid per processor architecture or overlap with SMRAM.
-**/
-BOOLEAN
-IsBufferOutsideMmValid (
-  IN EFI_PHYSICAL_ADDRESS  Buffer,
-  IN UINT64                Length
-  )
-{
-  return SmmIsBufferOutsideSmmValid (Buffer, Length);
-}
-
 /**
   The module Entry Point of the Firmware Performance Data Table MM driver.
 
   @param[in]  ImageHandle    The firmware allocated handle for the EFI image.
   @param[in]  SystemTable    A pointer to the EFI System Table.
-- 
2.18.0.windows.1

