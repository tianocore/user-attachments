From d88b5f9e9cf238b40c3f311f64451a329e5ec923 Mon Sep 17 00:00:00 2001
From: Loo Tung Lun <tung.lun.loo@intel.com>
Date: Tue, 22 Dec 2020 15:29:37 +0800
Subject: [PATCH] IntelFsp2Pkg: Add YAML file generation support

Add support for YAML format file generation in addition
to current BSF structure. Configuration of YAML format
output will be supported by an open source ConfigEditor.

Reference to YAML code, test and ConfigEditor is at
https://github.com/joshloo/fsp_yaml_cfg/tree/master/Tools

Signed-off-by: Loo Tung Lun <tung.lun.loo@intel.com>
---
 IntelFsp2Pkg/Tools/FspDscBsf2Yaml.py          |  642 ++++++
 IntelFsp2Pkg/Tools/GenCfgOpt.py               | 1980 ++++++++++++++++-
 .../UserManuals/FspDscBsf2YamlUserManual.md   |   39 +
 3 files changed, 2650 insertions(+), 11 deletions(-)
 create mode 100644 IntelFsp2Pkg/Tools/FspDscBsf2Yaml.py
 create mode 100644 IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual.md

diff --git a/IntelFsp2Pkg/Tools/FspDscBsf2Yaml.py b/IntelFsp2Pkg/Tools/FspDscBsf2Yaml.py
new file mode 100644
index 0000000000..da921e002b
--- /dev/null
+++ b/IntelFsp2Pkg/Tools/FspDscBsf2Yaml.py
@@ -0,0 +1,642 @@
+#!/usr/bin/env python
+## @ FspDscBsf2Yaml.py
+# This script convert FSP BSF format into DSC format
+#
+# Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+# SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+import os
+import re
+import sys
+import struct
+import argparse
+from   datetime    import date
+from   collections import OrderedDict
+from   functools   import reduce
+from   datetime    import date
+
+from GenCfgOpt import CFspBsf2Dsc, CGenCfgData
+
+__copyright_tmp__ = """## @file
+#
+#  Slim Bootloader CFGDATA %s File.
+#
+#  Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+"""
+
+class CFspDsc2Yaml ():
+
+    def __init__ (self):
+        self._Hdr_key_list  = ['EMBED', 'STRUCT']
+        self._Bsf_key_list  = ['NAME','HELP','TYPE','PAGE', 'PAGES', 'OPTION','CONDITION','ORDER', 'MARKER', 'SUBT', 'FIELD', 'FIND']
+        self.gen_cfg_data = None
+        self.cfg_reg_exp  = re.compile("^([_a-zA-Z0-9$\(\)]+)\s*\|\s*(0x[0-9A-F]+|\*)\s*\|\s*(\d+|0x[0-9a-fA-F]+)\s*\|\s*(.+)")
+        self.bsf_reg_exp  = re.compile("(%s):{(.+?)}(?:$|\s+)" % '|'.join(self._Bsf_key_list))
+        self.hdr_reg_exp  = re.compile("(%s):{(.+?)}" % '|'.join(self._Hdr_key_list))
+        self.prefix       = ''
+        self.unused_idx   = 0
+        self.offset       = 0
+        self.base_offset  = 0
+
+    def load_config_data_from_dsc (self, file_name):
+        """
+        Load and parse a DSC CFGDATA file.
+        """
+        gen_cfg_data = CGenCfgData('FSP')
+        if file_name.endswith('.dsc'):
+            if gen_cfg_data.ParseDscFile(file_name, '') != 0:
+                raise Exception('DSC file parsing error !')
+            if gen_cfg_data.CreateVarDict() != 0:
+                raise Exception('DSC variable creation error !')
+        else:
+            raise Exception('Unsupported file "%s" !' % file_name)
+        gen_cfg_data.UpdateDefaultValue()
+        self.gen_cfg_data = gen_cfg_data
+
+    def print_dsc_line (self):
+        """
+        Debug function to print all DSC lines.
+        """
+        for line in self.gen_cfg_data._DscLines:
+            print (line)
+
+    def format_value (self, field, text, indent = ''):
+        """
+        Format a CFGDATA item into YAML format.
+        """
+        if (not text.startswith('!expand')) and (': ' in text):
+            tgt = ':' if field == 'option' else '- '
+            text = text.replace(': ', tgt)
+        lines = text.splitlines()
+        if len(lines) == 1 and field != 'help':
+            return text
+        else:
+            return '>\n   ' + '\n   '.join ([indent + i.lstrip() for i in lines])
+
+    def reformat_pages (self, val):
+        # Convert XXX:YYY into XXX::YYY format for page definition
+        parts = val.split(',')
+        if len(parts) <= 1:
+            return val
+
+        new_val = []
+        for each in parts:
+            nodes = each.split(':')
+            if len(nodes) == 2:
+               each = '%s::%s' % (nodes[0], nodes[1])
+            new_val.append(each)
+        ret = ','.join (new_val)
+        return ret
+
+    def reformat_struct_value (self, utype, val):
+        # Convert DSC UINT16/32/64 array into new format by
+        # adding prefix 0:0[WDQ] to provide hint to the array format
+        if utype in ['UINT16', 'UINT32', 'UINT64']:
+            if val and val[0] == '{' and val[-1] == '}':
+                if utype == 'UINT16':
+                    unit = 'W'
+                elif utype == 'UINT32':
+                    unit = 'D'
+                else:
+                    unit = 'Q'
+                val = '{ 0:0%s, %s }' % (unit, val[1:-1])
+        return val
+
+    def process_config (self, cfg):
+        if 'page' in cfg:
+            cfg['page'] = self.reformat_pages (cfg['page'])
+
+        if 'struct' in cfg:
+            cfg['value'] = self.reformat_struct_value (cfg['struct'], cfg['value'])
+
+    def parse_dsc_line (self, dsc_line, config_dict, init_dict, include):
+        """
+        Parse a line in DSC and update the config dictionary accordingly.
+        """
+        init_dict.clear ()
+        match = re.match('g(CfgData|\w+FspPkgTokenSpaceGuid)\.(.+)', dsc_line)
+        if match:
+            match = self.cfg_reg_exp.match(match.group(2))
+            if not match:
+                return False
+            config_dict['cname']  = self.prefix + match.group(1)
+            value  = match.group(4).strip()
+            length = match.group(3).strip()
+            config_dict['length'] = length
+            config_dict['value'] = value
+            if match.group(2) == '*':
+                self.offset += int (length, 0)
+            else:
+                org_offset = int (match.group(2), 0)
+                if org_offset == 0:
+                    self.base_offset = self.offset
+                offset = org_offset + self.base_offset
+                if self.offset != offset:
+                    if offset > self.offset:
+                        init_dict['padding'] = offset - self.offset
+                self.offset = offset + int (length, 0)
+            return True
+
+        match = re.match("^\s*#\s+!([<>])\s+include\s+(.+)", dsc_line)
+        if match and len(config_dict) == 0:
+            # !include should not be inside a config field
+            # if so, do not convert include into YAML
+            init_dict = dict(config_dict)
+            config_dict.clear()
+            config_dict['cname']   = '$ACTION'
+            if match.group(1) == '<':
+                config_dict['include'] = match.group(2)
+            else:
+                config_dict['include'] = ''
+            return True
+
+        match = re.match("^\s*#\s+(!BSF|!HDR)\s+(.+)", dsc_line)
+        if not match:
+            return False
+
+        remaining = match.group(2)
+        if match.group(1) == '!BSF':
+            result = self.bsf_reg_exp.findall (remaining)
+            if not result:
+                return False
+
+            for each in result:
+                key = each[0].lower()
+                val = each[1]
+                if key == 'field':
+                    name = each[1]
+                    if ':' not in name:
+                        raise Exception ('Incorrect bit field format !')
+                    parts = name.split(':')
+                    config_dict['length'] = parts[1]
+                    config_dict['cname']  = '@' + parts[0]
+                    return True
+                elif key in ['pages', 'page', 'find']:
+                    init_dict = dict(config_dict)
+                    config_dict.clear()
+                    config_dict['cname'] = '$ACTION'
+                    if key == 'find':
+                        config_dict['find'] = val
+                    else:
+                        config_dict['page'] = val
+                    return True
+                elif key == 'subt':
+                    config_dict.clear()
+                    parts = each[1].split(':')
+                    tmp_name = parts[0][:-5]
+                    skey = parts[0].lower()
+                    if tmp_name == 'CFGHDR':
+                        cfg_tag = '_$FFF_'
+                        sval = '!expand { %s_TMPL : [ ' % tmp_name + '%s, %s, ' % (parts[1], cfg_tag) + ', '.join (parts[2:]) + ' ] }'
+                    else:
+                        sval = '!expand { %s_TMPL : [ ' % tmp_name + ', '.join (parts[1:]) + ' ] }'
+                    config_dict.clear()
+                    config_dict['cname']  = tmp_name
+                    config_dict['expand'] = sval
+                    return True
+                else:
+                    if key in ['name', 'help', 'option'] and val.startswith('+'):
+                        val = config_dict[key] + '\n' +  val[1:]
+                    if val.strip() == '':
+                        val = "''"
+                    config_dict[key] = val
+
+        else:
+            match = self.hdr_reg_exp.match(remaining)
+            if not match:
+                return False
+            key = match.group(1)
+            remaining = match.group(2)
+            if key  == 'EMBED':
+                parts = remaining.split(':')
+                names = parts[0].split(',')
+                if parts[-1] == 'END':
+                    prefix = '>'
+                else:
+                    prefix = '<'
+                skip = False
+                if parts[1].startswith('TAG_'):
+                    tag_txt = '%s:%s' % (names[0], parts[1])
+                else:
+                    tag_txt = names[0]
+                    if parts[2] in ['START', 'END']:
+                        if names[0] == 'PCIE_RP_PIN_CTRL[]':
+                            skip = True
+                        else:
+                            tag_txt = '%s:%s' % (names[0], parts[1])
+                if not skip:
+                    config_dict.clear()
+                    config_dict['cname'] = prefix + tag_txt
+                    return True
+
+            if key  == 'STRUCT':
+                text = remaining.strip()
+                config_dict[key.lower()] = text
+
+        return False
+
+
+    def process_template_lines (self, lines):
+        """
+        Process a line in DSC template section.
+        """
+        template_name = ''
+        bsf_temp_dict  = OrderedDict()
+        temp_file_dict = OrderedDict()
+        include_file  = ['.']
+
+        for line in lines:
+            match = re.match("^\s*#\s+!([<>])\s+include\s+(.+)", line)
+            if match:
+                if match.group(1) == '<':
+                    include_file.append(match.group(2))
+                else:
+                    include_file.pop()
+
+            match = re.match("^\s*#\s+(!BSF)\s+DEFT:{(.+?):(START|END)}", line)
+            if match:
+                if match.group(3) == 'START' and not template_name:
+                    template_name = match.group(2).strip()
+                    temp_file_dict[template_name] = list(include_file)
+                    bsf_temp_dict[template_name]  = []
+                if match.group(3) == 'END' and (template_name == match.group(2).strip()) and template_name:
+                    template_name = ''
+            else:
+                if template_name:
+                    bsf_temp_dict[template_name].append(line)
+        return bsf_temp_dict, temp_file_dict
+
+
+    def process_option_lines (self, lines):
+        """
+        Process a line in DSC config section.
+        """
+        cfgs         = []
+        struct_end   = False
+        config_dict  = dict()
+        init_dict    = dict()
+        include     = ['']
+        for line in lines:
+            ret = self.parse_dsc_line (line, config_dict, init_dict, include)
+            if ret:
+                if 'padding' in init_dict:
+                    num = init_dict['padding']
+                    init_dict.clear()
+                    padding_dict = {}
+                    cfgs.append (padding_dict)
+                    padding_dict['cname']  = 'UnusedUpdSpace%d' % self.unused_idx
+                    padding_dict['length'] = '0x%x' % num
+                    padding_dict['value']  = '{ 0 }'
+                    self.unused_idx += 1
+
+                if cfgs and cfgs[-1]['cname'][0] != '@' and config_dict['cname'][0] == '@':
+                    # it is a bit field, mark the previous one as virtual
+                    cname = cfgs[-1]['cname']
+                    new_cfg = dict(cfgs[-1])
+                    new_cfg['cname'] = '@$STRUCT'
+                    cfgs[-1].clear ()
+                    cfgs[-1]['cname'] = cname
+                    cfgs.append(new_cfg)
+
+                if cfgs and cfgs[-1]['cname'] == 'CFGHDR' and config_dict['cname'][0] == '<':
+                    # swap CfgHeader and the CFG_DATA order
+                    if ':' in config_dict['cname']:
+                        # replace the real TAG for CFG_DATA
+                        cfgs[-1]['expand'] = cfgs[-1]['expand'].replace('_$FFF_', '0x%s' % config_dict['cname'].split(':')[1][4:])
+                    cfgs.insert (-1, config_dict)
+                else:
+                    self.process_config (config_dict)
+                    if  struct_end:
+                        struct_end = False
+                        cfgs.insert (-1, config_dict)
+                    else:
+                        cfgs.append (config_dict)
+                        if  config_dict['cname'][0] == '>':
+                            struct_end = True
+
+                config_dict = dict(init_dict)
+        return cfgs
+
+
+    def variable_fixup (self, each):
+        """
+        Fix up some variable definitions for SBL.
+        """
+        key = each
+        val = self.gen_cfg_data._MacroDict[each]
+        return key, val
+
+
+    def template_fixup (self, tmp_name, tmp_list):
+        """
+        Fix up some special config templates for SBL
+        """
+        return
+
+    def config_fixup (self, cfg_list):
+        """
+        Fix up some special config items for SBL.
+        """
+
+        # Insert FSPT_UPD/FSPM_UPD/FSPS_UPD tag so as to create C strcture
+        idxs = []
+        for idx, cfg in enumerate(cfg_list):
+            if cfg['cname'].startswith('<FSP_UPD_HEADER'):
+                idxs.append(idx)
+
+        if len(idxs) != 3:
+            return
+
+        # Handle insert backwards so that the index does not change in the loop
+        fsp_comp = 'SMT'
+        idx_comp = 0
+        for idx in idxs[::-1]:
+            # Add current FSP?_UPD start tag
+            cfgfig_dict = {}
+            cfgfig_dict['cname'] = '<FSP%s_UPD' % fsp_comp[idx_comp]
+            cfg_list.insert(idx, cfgfig_dict)
+            if idx_comp < 2:
+                # Add previous FSP?_UPD end tag
+                cfgfig_dict = {}
+                cfgfig_dict['cname'] = '>FSP%s_UPD' % fsp_comp[idx_comp + 1]
+                cfg_list.insert(idx, cfgfig_dict)
+            idx_comp += 1
+
+        # Add final FSPS_UPD end tag
+        cfgfig_dict = {}
+        cfgfig_dict['cname'] = '>FSP%s_UPD' % fsp_comp[0]
+        cfg_list.append(cfgfig_dict)
+
+        return
+
+    def get_section_range (self, section_name):
+        """
+        Extract line number range from config file for a given section name.
+        """
+        start = -1
+        end   = -1
+        for idx, line in enumerate (self.gen_cfg_data._DscLines):
+            if start <0 and line.startswith('[%s]' % section_name):
+                start = idx
+            elif start >= 0 and line.startswith('['):
+                end   = idx
+                break
+        if start == -1:
+            start = 0
+        if end == -1:
+            end = len(self.gen_cfg_data._DscLines)
+        return start, end
+
+    def normalize_file_name (self, file, is_temp = False):
+        """
+        Normalize file name convention so that it is consistent.
+        """
+        if file.endswith('.dsc'):
+            file = file[:-4] + '.yaml'
+        dir_name  = os.path.dirname (file)
+        base_name = os.path.basename (file)
+        if is_temp:
+            if 'Template_' not in file:
+                base_name = base_name.replace ('Template', 'Template_')
+        else:
+            if 'CfgData_' not in file:
+                base_name = base_name.replace ('CfgData', 'CfgData_')
+        if dir_name:
+            path = dir_name + '/' + base_name
+        else:
+            path = base_name
+        return path
+
+    def output_variable (self):
+        """
+        Output variable block into a line list.
+        """
+        lines = []
+        for each in self.gen_cfg_data._MacroDict:
+            key, value = self.variable_fixup (each)
+            lines.append ('%-30s : %s' % (key,  value))
+        return lines
+
+    def output_template (self):
+        """
+        Output template block into a line list.
+        """
+        self.offset      = 0
+        self.base_offset = 0
+        start, end   = self.get_section_range ('PcdsDynamicVpd.Tmp')
+        bsf_temp_dict, temp_file_dict = self.process_template_lines (self.gen_cfg_data._DscLines[start:end])
+        template_dict = dict()
+        lines = []
+        file_lines = {}
+        last_file = '.'
+        file_lines[last_file] = []
+
+        for tmp_name in temp_file_dict:
+            temp_file_dict[tmp_name][-1] = self.normalize_file_name(temp_file_dict[tmp_name][-1], True)
+            if len(temp_file_dict[tmp_name]) > 1:
+                temp_file_dict[tmp_name][-2] = self.normalize_file_name(temp_file_dict[tmp_name][-2], True)
+
+        for tmp_name in bsf_temp_dict:
+            file = temp_file_dict[tmp_name][-1]
+            if last_file != file and len(temp_file_dict[tmp_name]) > 1:
+                inc_file = temp_file_dict[tmp_name][-2]
+                file_lines[inc_file].extend (['', '- !include %s' % temp_file_dict[tmp_name][-1], ''])
+            last_file = file
+            if file not in file_lines:
+                file_lines[file] = []
+            lines = file_lines[file]
+            text = bsf_temp_dict[tmp_name]
+            tmp_list = self.process_option_lines (text)
+            self.template_fixup (tmp_name, tmp_list)
+            template_dict[tmp_name] = tmp_list
+            lines.append ('%s: >' % tmp_name)
+            lines.extend (self.output_dict (tmp_list, False)['.'])
+            lines.append ('\n')
+        return file_lines
+
+
+    def output_config (self):
+        """
+        Output config block into a line list.
+        """
+        self.offset      = 0
+        self.base_offset = 0
+        start, end = self.get_section_range ('PcdsDynamicVpd.Upd')
+        cfgs = self.process_option_lines (self.gen_cfg_data._DscLines[start:end])
+        self.config_fixup (cfgs)
+        file_lines = self.output_dict (cfgs, True)
+        return file_lines
+
+
+    def output_dict (self, cfgs, is_configs ):
+        """
+        Output one config item into a line list.
+        """
+        file_lines = {}
+        level = 0
+        file  = '.'
+        for each in cfgs:
+            if 'length' in each and int(each['length'],0) == 0:
+                continue
+
+            if 'include' in each:
+                if each['include']:
+                    each['include'] = self.normalize_file_name(each['include'])
+                    file_lines[file].extend (['', '- !include %s' % each['include'], ''])
+                    file = each['include']
+                else:
+                    file = '.'
+                continue
+
+            if file not in file_lines:
+                file_lines[file] = []
+
+            lines  = file_lines[file]
+            name   = each['cname']
+
+            prefix = name[0]
+            if prefix == '<':
+                level += 1
+
+            padding = '  ' * level
+            if prefix not in '<>@':
+                padding += '  '
+            else:
+                name = name[1:]
+                if prefix == '@':
+                    padding += '    '
+
+            if ':' in name:
+                parts = name.split(':')
+                name = parts[0]
+
+            padding = padding[2:] if is_configs else padding
+
+            if prefix != '>':
+                if 'expand' in each:
+                    lines.append ('%s- %s' % (padding, each['expand']))
+                else:
+                    lines.append ('%s- %-12s :' % (padding , name))
+
+            for field in each:
+                if field in ['cname', 'expand', 'include']:
+                    continue
+                value_str = self.format_value (field, each[field], padding + ' ' * 16)
+                full_line = '  %s  %-12s : %s' % (padding, field, value_str)
+                lines.extend(full_line.splitlines())
+
+            if prefix == '>':
+                level -= 1
+                if level == 0:
+                    lines.append ('')
+
+        return file_lines
+
+
+def bsf_to_dsc (bsf_file, dsc_file):
+    fsp_dsc   = CFspBsf2Dsc (bsf_file)
+    dsc_lines = fsp_dsc.get_dsc_lines ()
+    fd = open (dsc_file, 'w')
+    fd.write('\n'.join(dsc_lines))
+    fd.close()
+    return
+
+def dsc_to_yaml (dsc_file, yaml_file):
+    dsc2yaml = CFspDsc2Yaml ()
+    dsc2yaml.load_config_data_from_dsc (dsc_file)
+
+    cfgs = {}
+    for cfg in ['Template', 'Option']:
+        if cfg == 'Template':
+            file_lines = dsc2yaml.output_template ()
+        else:
+            file_lines = dsc2yaml.output_config ()
+        for file in file_lines:
+            lines = file_lines[file]
+            if file == '.':
+                cfgs[cfg] = lines
+            else:
+                if ('/' in file or '\\' in file) and not gen_all:
+                    continue
+                file = os.path.basename(file)
+                fo = open(os.path.join(out_dir, file), 'w')
+                fo.write (__copyright_tmp__ % (cfg, date.today().year) + '\n\n')
+                for line in lines:
+                    fo.write(line + '\n')
+                fo.close()
+
+    variables = dsc2yaml.output_variable ()
+    fo = open(yaml_file, 'w')
+    fo.write (__copyright_tmp__ % ('Default', date.today().year))
+    if len(variables) > 0:
+        fo.write ('\n\nvariable:\n')
+        for line in variables:
+            fo.write('  ' + line + '\n')
+
+    fo.write ('\n\ntemplate:\n')
+    for line in cfgs['Template']:
+        fo.write('  ' + line + '\n')
+
+    fo.write ('\n\nconfigs:\n')
+    for line in cfgs['Option']:
+        fo.write('  ' + line + '\n')
+
+    fo.close()
+
+
+def get_fsp_name_from_path (bsf_file):
+    name = ''
+    parts = bsf_file.split(os.sep)
+    for part in parts:
+        if part.endswith ('FspBinPkg'):
+            name = part[:-9]
+            break
+    if not name:
+        raise Exception ('Could not get FSP name from file path!')
+    return name
+
+
+def usage():
+    print ('\n'.join([
+          "FspDscBsf2Yaml Version 0.10",
+          "Usage:",
+          "    FspDscBsf2Yaml  BsfFile|DscFile  YamlFile"
+          ]))
+
+
+def main():
+    #
+    # Parse the options and args
+    #
+    argc = len(sys.argv)
+    if argc < 3:
+        usage()
+        return 1
+
+    bsf_file  = sys.argv[1]
+    yaml_file = sys.argv[2]
+    if os.path.isdir(yaml_file):
+        yaml_file = os.path.join(yaml_file, get_fsp_name_from_path(bsf_file) + '.yaml')
+
+    if bsf_file.endswith('.dsc'):
+        dsc_file = bsf_file
+        bsf_file = ''
+    else:
+        dsc_file  = os.path.splitext(yaml_file)[0] + '.dsc'
+        bsf_to_dsc  (bsf_file, dsc_file)
+
+    dsc_to_yaml (dsc_file, yaml_file)
+
+    print ("'%s' was created successfully!" % yaml_file)
+
+    return 0
+
+
+if __name__ == '__main__':
+    sys.exit(main())
+
+
diff --git a/IntelFsp2Pkg/Tools/GenCfgOpt.py b/IntelFsp2Pkg/Tools/GenCfgOpt.py
index a0b8bba81e..dbfa46a70b 100644
--- a/IntelFsp2Pkg/Tools/GenCfgOpt.py
+++ b/IntelFsp2Pkg/Tools/GenCfgOpt.py
@@ -282,6 +282,1973 @@ class CLogicalExpression:
             Result = False
         return Result
 
+class CFspBsf2Dsc:
+
+    def __init__ (self, bsf_file):
+        self.cfg_list  = CFspBsf2Dsc.parse_bsf(bsf_file)
+
+    def get_dsc_lines (self):
+        return CFspBsf2Dsc.generate_dsc (self.cfg_list)
+
+    def save_dsc (self, dsc_file):
+        return CFspBsf2Dsc.generate_dsc (self.cfg_list, dsc_file)
+
+    @staticmethod
+    def parse_bsf(bsf_file):
+
+        fd = open(bsf_file, 'r')
+        bsf_txt = fd.read()
+        fd.close()
+
+        find_list = []
+        regex = re.compile(r'\s+Find\s+"(.*?)"(.*?)^\s+\$(.*?)\s+', re.S | re.MULTILINE)
+        for match in regex.finditer(bsf_txt):
+            find = match.group(1)
+            name = match.group(3)
+            if not name.endswith('_Revision'):
+                raise Exception ("Unexpected CFG item following 'Find' !")
+            find_list.append ((name, find))
+
+        idx = 0
+        count     = 0
+        prefix    = ''
+        chk_dict  = {}
+        cfg_list  = []
+        cfg_temp  = { 'find':'', 'cname':'', 'length': 0, 'value':'0', 'type':'Reserved',
+                      'embed':'', 'page':'', 'option':'', 'instance':0}
+        regex = re.compile(
+            r'^\s+(\$(.*?)|Skip)\s+(\d+)\s+bytes(\s+\$_DEFAULT_\s+=\s+(.+?))?$', re.S |
+            re.MULTILINE)
+
+        for match in regex.finditer(bsf_txt):
+            dlen = int(match.group(3))
+            if match.group(1) == 'Skip':
+                key  = 'gPlatformFspPkgTokenSpaceGuid_BsfSkip%d' % idx
+                val  = ', '.join(['%02X'  % ord(i) for i in '\x00' * dlen])
+                idx += 1
+                option = '$SKIP'
+            else:
+                key = match.group(2)
+                val = match.group(5)
+                option = ''
+
+            cfg_item = dict(cfg_temp)
+            finds = [i for i in find_list if i[0] == key]
+            if len(finds) > 0:
+                if count >= 1:
+                    # Append a dummy one
+                    cfg_item['cname'] = 'Dummy'
+                    cfg_list.append(dict(cfg_item))
+                    cfg_list[-1]['embed'] = '%s:TAG_%03X:END' % (prefix, ord(prefix[-1]))
+                prefix = finds[0][1]
+                cfg_item['embed'] = '%s:TAG_%03X:START' % (prefix, ord(prefix[-1]))
+                cfg_item['find'] = prefix
+                cfg_item['cname']  = 'Signature'
+                cfg_item['length'] = len(finds[0][1])
+                cfg_item['value']  = '0x%X' % Bytes2Val (finds[0][1].encode('UTF-8'))
+
+
+                cfg_list.append(dict(cfg_item))
+                cfg_item = dict(cfg_temp)
+                find_list.pop(0)
+                count = 0
+
+            cfg_item['cname']    = key
+            cfg_item['length']   = dlen
+            cfg_item['value']    = val
+            cfg_item['option']   = option
+
+            if key not in chk_dict.keys():
+                chk_dict[key]  = 0
+            else:
+                chk_dict[key] += 1
+            cfg_item['instance'] = chk_dict[key]
+
+            cfg_list.append(cfg_item)
+            count += 1
+
+        if prefix:
+            cfg_item = dict(cfg_temp)
+            cfg_item['cname'] = 'Dummy'
+            cfg_item['embed'] = '%s:%03X:END' % (prefix, ord(prefix[-1]))
+            cfg_list.append (cfg_item)
+
+        option_dict = {}
+        selreg = re.compile(r'\s+Selection\s*(.+?)\s*,\s*"(.*?)"$', re.S |
+                            re.MULTILINE)
+        regex = re.compile(r'^List\s&(.+?)$(.+?)^EndList$', re.S | re.MULTILINE)
+        for match in regex.finditer(bsf_txt):
+            key = match.group(1)
+            option_dict[key] = []
+            for select in selreg.finditer(match.group(2)):
+                option_dict[key].append((int(select.group(1), 0), select.group(2)))
+
+
+        chk_dict  = {}
+        pagereg = re.compile(r'^Page\s"(.*?)"$(.+?)^EndPage$', re.S | re.MULTILINE)
+        for match in pagereg.finditer(bsf_txt):
+            page = match.group(1)
+            for line in match.group(2).splitlines():
+                match = re.match('\s+(Combo|EditNum)\s\$(.+?),\s"(.*?)",\s(.+?),$', line)
+                if match:
+                    cname = match.group(2)
+                    if cname not in chk_dict.keys():
+                        chk_dict[cname]  = 0
+                    else:
+                        chk_dict[cname] += 1
+                    instance = chk_dict[cname]
+                    cfg_idxs = [i for i, j in enumerate(cfg_list) if j['cname'] == cname and j['instance'] == instance]
+                    if len(cfg_idxs) != 1:
+                        raise Exception ("Multiple CFG item '%s' found !" % cname)
+                    cfg_item = cfg_list[cfg_idxs[0]]
+                    cfg_item['page']   = page
+                    cfg_item['type']   = match.group(1)
+                    cfg_item['prompt'] = match.group(3)
+                    cfg_item['range']  = None
+                    if cfg_item['type'] == 'Combo':
+                        cfg_item['option'] = option_dict[match.group(4)[1:]]
+                    elif cfg_item['type'] == 'EditNum':
+                        cfg_item['option'] = match.group(4)
+                match = re.match('\s+ Help\s"(.*?)"$', line)
+                if match:
+                    cfg_item['help'] = match.group(1)
+
+                match = re.match('\s+"Valid\srange:\s(.*)"$', line)
+                if match:
+                    parts = match.group(1).split()
+                    cfg_item['option'] = (
+                        (int(parts[0], 0), int(parts[2], 0), cfg_item['option']))
+
+        return cfg_list
+
+    @staticmethod
+    def generate_dsc(option_list, dsc_file = None):
+        dsc_lines = []
+        header = '%s' % (__copyright_dsc__ % date.today().year)
+        dsc_lines.extend (header.splitlines())
+
+        pages = []
+        for cfg_item in option_list:
+            if cfg_item['page'] and (cfg_item['page'] not in pages):
+                pages.append (cfg_item['page'])
+
+        page_id   = 0
+        for page in pages:
+            dsc_lines.append('  # !BSF PAGES:{PG%02X::"%s"}' % (page_id, page))
+            page_id += 1
+        dsc_lines.append('')
+
+        last_page = ''
+        for option in option_list:
+            dsc_lines.append ('')
+            default = option['value']
+            pos = option['cname'].find('_')
+            name = option['cname'][pos + 1:]
+
+            if option['find']:
+                dsc_lines.append('  # !BSF FIND:{%s}' % option['find'])
+                dsc_lines.append('')
+
+            if option['instance'] > 0:
+                name = name + '_%s' % option['instance']
+
+            if option['embed']:
+                dsc_lines.append('  # !HDR EMBED:{%s}' % option['embed'])
+
+            if option['type'] == 'Reserved':
+                dsc_lines.append('  # !BSF NAME:{Reserved} TYPE:{Reserved}')
+                if option['option'] == '$SKIP':
+                    dsc_lines.append('  # !BSF OPTION:{$SKIP}')
+            else:
+                prompt = option['prompt']
+
+                if last_page != option['page']:
+                    last_page = option['page']
+                    dsc_lines.append('  # !BSF PAGE:{PG%02X}' % (pages.index( option['page'])))
+
+                if option['type'] == 'Combo':
+                    dsc_lines.append('  # !BSF NAME:{%s} TYPE:{%s}' %
+                                     (prompt, option['type']))
+                    ops = []
+                    for val, text in option['option']:
+                        ops.append('0x%x:%s' % (val, text))
+                    dsc_lines.append('  # !BSF OPTION:{%s}' % (', '.join(ops)))
+                elif option['type'] == 'EditNum':
+                    cfg_len = option['length']
+                    if ',' in default and cfg_len > 8:
+                        dsc_lines.append('  # !BSF NAME:{%s} TYPE:{Table}' % (prompt))
+                        if cfg_len > 16:
+                            cfg_len = 16
+                        ops = []
+                        for i in range(cfg_len):
+                            ops.append('%X:1:HEX' % i)
+                        dsc_lines.append('  # !BSF OPTION:{%s}' % (', '.join(ops)))
+                    else:
+                        dsc_lines.append(
+                            '  # !BSF NAME:{%s} TYPE:{%s, %s, (0x%X, 0x%X)}' %
+                            (prompt, option['type'], option['option'][2],
+                             option['option'][0], option['option'][1]))
+                dsc_lines.append('  # !BSF HELP:{%s}' % option['help'])
+
+            if ',' in default:
+                default = '{%s}' % default
+            dsc_lines.append('  gCfgData.%-30s | * | 0x%04X | %s' %
+                             (name, option['length'], default))
+
+        if dsc_file:
+            fd = open(dsc_file, 'w')
+            fd.write('\n'.join(dsc_lines))
+            fd.close()
+
+        return dsc_lines
+
+
+
+class CGenCfgData:
+    def __init__(self, Mode = ''):
+        self.Debug          = False
+        self.Error          = ''
+        self.ReleaseMode    = True
+        self.Mode           = Mode
+        self._GlobalDataDef = """
+GlobalDataDef
+    SKUID = 0, "DEFAULT"
+EndGlobalData
+
+"""
+        self._BuidinOptionTxt = """
+List &EN_DIS
+    Selection 0x1 , "Enabled"
+    Selection 0x0 , "Disabled"
+EndList
+
+"""
+        self._StructType    = ['UINT8','UINT16','UINT32','UINT64']
+        self._BsfKeyList    = ['FIND','NAME','HELP','TYPE','PAGE', 'PAGES', 'BLOCK', 'OPTION','CONDITION','ORDER', 'MARKER', 'SUBT']
+        self._HdrKeyList    = ['HEADER','STRUCT', 'EMBED', 'COMMENT']
+        self._BuidinOption  = {'$EN_DIS' : 'EN_DIS'}
+
+        self._MacroDict   = {}
+        self._VarDict     = {}
+        self._PcdsDict    = {}
+        self._CfgBlkDict  = {}
+        self._CfgPageDict = {}
+        self._CfgOptsDict = {}
+        self._BsfTempDict = {}
+        self._CfgItemList = []
+        self._DscLines    = []
+        self._DscFile     = ''
+        self._CfgPageTree = {}
+
+        self._MapVer      = 0
+        self._MinCfgTagId = 0x100
+
+    def ParseMacros (self, MacroDefStr):
+        # ['-DABC=1', '-D', 'CFG_DEBUG=1', '-D', 'CFG_OUTDIR=Build']
+        self._MacroDict = {}
+        IsExpression = False
+        for Macro in MacroDefStr:
+            if Macro.startswith('-D'):
+                IsExpression = True
+                if len(Macro) > 2:
+                    Macro = Macro[2:]
+                else :
+                    continue
+            if IsExpression:
+                IsExpression = False
+                Match = re.match("(\w+)=(.+)", Macro)
+                if Match:
+                    self._MacroDict[Match.group(1)] = Match.group(2)
+                else:
+                    Match = re.match("(\w+)", Macro)
+                    if Match:
+                        self._MacroDict[Match.group(1)] = ''
+        if len(self._MacroDict) == 0:
+            Error = 1
+        else:
+            Error = 0
+            if self.Debug:
+                print ("INFO : Macro dictionary:")
+                for Each in self._MacroDict:
+                    print ("       $(%s) = [ %s ]" % (Each , self._MacroDict[Each]))
+        return Error
+
+    def EvaulateIfdef   (self, Macro):
+        Result = Macro in self._MacroDict
+        if self.Debug:
+            print ("INFO : Eval Ifdef [%s] : %s" % (Macro, Result))
+        return  Result
+
+    def ExpandMacros (self, Input, Preserve = False):
+        Line = Input
+        Match = re.findall("\$\(\w+\)", Input)
+        if Match:
+            for Each in Match:
+              Variable = Each[2:-1]
+              if Variable in self._MacroDict:
+                  Line = Line.replace(Each, self._MacroDict[Variable])
+              else:
+                  if self.Debug:
+                      print ("WARN : %s is not defined" % Each)
+                  if not Preserve:
+                      Line = Line.replace(Each, Each[2:-1])
+        return Line
+
+    def ExpandPcds (self, Input):
+        Line = Input
+        Match = re.findall("(\w+\.\w+)", Input)
+        if Match:
+            for PcdName in Match:
+              if PcdName in self._PcdsDict:
+                  Line = Line.replace(PcdName, self._PcdsDict[PcdName])
+              else:
+                  if self.Debug:
+                      print ("WARN : %s is not defined" % PcdName)
+        return Line
+
+    def EvaluateExpress (self, Expr):
+        ExpExpr = self.ExpandPcds(Expr)
+        ExpExpr = self.ExpandMacros(ExpExpr)
+        LogExpr = CLogicalExpression()
+        Result  = LogExpr.evaluateExpress (ExpExpr)
+        if self.Debug:
+            print ("INFO : Eval Express [%s] : %s" % (Expr, Result))
+        return Result
+
+    def ValueToByteArray (self, ValueStr, Length):
+        Match = re.match("\{\s*FILE:(.+)\}", ValueStr)
+        if Match:
+          FileList = Match.group(1).split(',')
+          Result  = bytearray()
+          for File in FileList:
+            File = File.strip()
+            BinPath = os.path.join(os.path.dirname(self._DscFile), File)
+            Result.extend(bytearray(open(BinPath, 'rb').read()))
+        else:
+            try:
+                Result  = bytearray(self.ValueToList(ValueStr, Length))
+            except ValueError as e:
+                raise Exception ("Bytes in '%s' must be in range 0~255 !" % ValueStr)
+        if len(Result) < Length:
+            Result.extend(b'\x00' * (Length - len(Result)))
+        elif len(Result) > Length:
+            raise Exception ("Value '%s' is too big to fit into %d bytes !" % (ValueStr, Length))
+
+        return Result[:Length]
+
+    def ValueToList (self, ValueStr, Length):
+        if ValueStr[0] == '{':
+            Result = []
+            BinList = ValueStr[1:-1].split(',')
+            InBitField     = False
+            LastInBitField = False
+            Value          = 0
+            BitLen         = 0
+            for Element in BinList:
+                InBitField = False
+                Each = Element.strip()
+                if len(Each) == 0:
+                    pass
+                else:
+                    if Each[0] in ['"', "'"]:
+                        Result.extend(list(bytearray(Each[1:-1], 'utf-8')))
+                    elif ':' in Each:
+                        Match    = re.match("(.+):(\d+)b", Each)
+                        if Match is None:
+                            raise Exception("Invald value list format '%s' !" % Each)
+                        InBitField = True
+                        CurrentBitLen = int(Match.group(2))
+                        CurrentValue  = ((self.EvaluateExpress(Match.group(1)) & (1<<CurrentBitLen) - 1)) << BitLen
+                    else:
+                        Result.append(self.EvaluateExpress(Each.strip()))
+                if InBitField:
+                    Value  += CurrentValue
+                    BitLen += CurrentBitLen
+                if LastInBitField and ((not InBitField) or (Element == BinList[-1])):
+                    if BitLen % 8 != 0:
+                        raise Exception("Invald bit field length!")
+                    Result.extend(Val2Bytes(Value, BitLen // 8))
+                    Value  = 0
+                    BitLen = 0
+                LastInBitField = InBitField
+        elif ValueStr.startswith("'") and ValueStr.endswith("'"):
+            Result = Str2Bytes (ValueStr, Length)
+        elif ValueStr.startswith('"') and ValueStr.endswith('"'):
+            Result = Str2Bytes (ValueStr, Length)
+        else:
+            Result = Val2Bytes (self.EvaluateExpress(ValueStr), Length)
+        return Result
+
+    def FormatDeltaValue(self, ConfigDict):
+        ValStr = ConfigDict['value']
+        if ValStr[0] == "'":
+            # Remove padding \x00 in the value string
+            ValStr = "'%s'" % ValStr[1:-1].rstrip('\x00')
+
+        Struct = ConfigDict['struct']
+        if Struct in self._StructType:
+            # Format the array using its struct type
+            Unit   = int(Struct[4:]) // 8
+            Value  = Array2Val(ConfigDict['value'])
+            Loop   = ConfigDict['length'] // Unit
+            Values = []
+            for Each in range(Loop):
+                Values.append (Value & ((1 << (Unit * 8)) - 1))
+                Value = Value >> (Unit * 8)
+            ValStr = '{ ' + ', '.join ([('0x%%0%dX' % (Unit * 2)) % x for x in Values]) + ' }'
+
+        return ValStr
+
+    def FormatListValue(self, ConfigDict):
+        Struct = ConfigDict['struct']
+        if Struct not in self._StructType:
+            return
+
+        DataList = self.ValueToList(ConfigDict['value'], ConfigDict['length'])
+        Unit = int(Struct[4:]) // 8
+        if int(ConfigDict['length']) != Unit * len(DataList):
+            # Fallback to byte array
+            Unit = 1
+            if int(ConfigDict['length']) != len(DataList):
+                raise Exception("Array size is not proper for '%s' !" % ConfigDict['cname'])
+
+        ByteArray = []
+        for Value in DataList:
+            for Loop in range(Unit):
+                ByteArray.append("0x%02X" % (Value & 0xFF))
+                Value = Value >> 8
+        NewValue  = '{'  + ','.join(ByteArray) + '}'
+        ConfigDict['value'] = NewValue
+
+        return ""
+
+    def GetOrderNumber (self, Offset, Order, BitOff = 0):
+        if isinstance(Order, int):
+            if Order == -1:
+                Order = Offset << 16
+        else:
+            (Major, Minor) = Order.split('.')
+            Order = (int (Major, 16) << 16) + ((int (Minor, 16) & 0xFF) << 8)
+        return Order + (BitOff & 0xFF)
+
+    def SubtituteLine (self, Line, Args):
+        Args = Args.strip()
+        Vars = Args.split(':')
+        Line = self.ExpandMacros(Line, True)
+        for Idx in range(len(Vars)-1, 0, -1):
+            Line = Line.replace('$(%d)' % Idx, Vars[Idx].strip())
+        return Line
+
+    def CfgDuplicationCheck (self, CfgDict, Name):
+        if not self.Debug:
+            return
+
+        if Name == 'Dummy':
+            return
+
+        if Name not in CfgDict:
+            CfgDict[Name] = 1
+        else:
+            print ("WARNING: Duplicated item found '%s' !" % ConfigDict['cname'])
+
+    def AddBsfChildPage (self, Child, Parent = 'root'):
+        def AddBsfChildPageRecursive (PageTree, Parent, Child):
+            Key = next(iter(PageTree))
+            if Parent == Key:
+                PageTree[Key].append({Child : []})
+                return True
+            else:
+                Result = False
+                for Each in PageTree[Key]:
+                    if AddBsfChildPageRecursive (Each, Parent, Child):
+                        Result = True
+                        break
+                return Result
+
+        return AddBsfChildPageRecursive (self._CfgPageTree, Parent, Child)
+
+    def ParseDscFile (self, DscFile, FvDir):
+        self._DscLines    = []
+        self._CfgItemList = []
+        self._CfgPageDict = {}
+        self._CfgBlkDict  = {}
+        self._BsfTempDict = {}
+        self._CfgPageTree = {'root' : []}
+        self._FvDir       = FvDir
+
+        CfgDict = {}
+
+        SectionNameList = ["Defines".lower(), "PcdsFeatureFlag".lower(),
+                           "PcdsDynamicVpd.Tmp".lower(), "PcdsDynamicVpd.Upd".lower()]
+
+        IsDefSect       = False
+        IsPcdSect       = False
+        IsUpdSect       = False
+        IsTmpSect       = False
+
+        TemplateName    = ''
+
+        IfStack         = []
+        ElifStack       = []
+        Error           = 0
+        ConfigDict      = {}
+
+        if type(DscFile) is list:
+            # it is DSC lines already
+            DscLines       = DscFile
+            self._DscFile  = '.'
+        else:
+            DscFd        = open(DscFile, "r")
+            DscLines     = DscFd.readlines()
+            DscFd.close()
+            self._DscFile = DscFile
+
+        BsfRegExp    = re.compile("(%s):{(.+?)}(?:$|\s+)" % '|'.join(self._BsfKeyList))
+        HdrRegExp    = re.compile("(%s):{(.+?)}" % '|'.join(self._HdrKeyList))
+        CfgRegExp    = re.compile("^([_a-zA-Z0-9]+)\s*\|\s*(0x[0-9A-F]+|\*)\s*\|\s*(\d+|0x[0-9a-fA-F]+)\s*\|\s*(.+)")
+        TksRegExp    = re.compile("^(g[_a-zA-Z0-9]+\.)(.+)")
+        SkipLines = 0
+        while len(DscLines):
+            DscLine  = DscLines.pop(0).strip()
+            if SkipLines == 0:
+              self._DscLines.append (DscLine)
+            else:
+              SkipLines = SkipLines - 1
+            if len(DscLine) == 0:
+              continue
+
+            Handle   = False
+            Match    = re.match("^\[(.+)\]", DscLine)
+            if Match is not None:
+                IsDefSect = False
+                IsPcdSect = False
+                IsUpdSect = False
+                IsTmpSect = False
+                SectionName = Match.group(1).lower()
+                if  SectionName  == SectionNameList[0]:
+                    IsDefSect = True
+                if  SectionName  == SectionNameList[1]:
+                    IsPcdSect = True
+                elif SectionName == SectionNameList[2]:
+                    IsTmpSect = True
+                elif SectionName == SectionNameList[3]:
+                    ConfigDict = {
+                        'header'    : 'ON',
+                        'page'      : '',
+                        'name'      : '',
+                        'find'      : '',
+                        'struct'    : '',
+                        'embed'     : '',
+                        'marker'    : '',
+                        'option'    : '',
+                        'comment'   : '',
+                        'condition' : '',
+                        'order'     : -1,
+                        'subreg'    : []
+                    }
+                    IsUpdSect = True
+                    Offset    = 0
+            else:
+                if IsDefSect or IsPcdSect or IsUpdSect or IsTmpSect:
+                    Match = False if DscLine[0] != '!' else True
+                    if Match:
+                        Match = re.match("^!(else|endif|ifdef|ifndef|if|elseif|include)\s*(.+)?$", DscLine.split("#")[0])
+                    Keyword   = Match.group(1) if Match else ''
+                    Remaining = Match.group(2) if Match else ''
+                    Remaining = '' if Remaining is None else Remaining.strip()
+
+                    if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and not Remaining:
+                        raise Exception ("ERROR: Expression is expected after '!if' or !elseif' for line '%s'" % DscLine)
+
+                    if Keyword == 'else':
+                        if IfStack:
+                            IfStack[-1] = not IfStack[-1]
+                        else:
+                            raise Exception ("ERROR: No paired '!if' found for '!else' for line '%s'" % DscLine)
+                    elif Keyword == 'endif':
+                        if IfStack:
+                            IfStack.pop()
+                            Level = ElifStack.pop()
+                            if Level > 0:
+                                del IfStack[-Level:]
+                        else:
+                            raise Exception ("ERROR: No paired '!if' found for '!endif' for line '%s'" % DscLine)
+                    elif Keyword == 'ifdef' or Keyword == 'ifndef':
+                        Result = self.EvaulateIfdef (Remaining)
+                        if Keyword == 'ifndef':
+                            Result = not Result
+                        IfStack.append(Result)
+                        ElifStack.append(0)
+                    elif Keyword == 'if' or Keyword == 'elseif':
+                        Result = self.EvaluateExpress(Remaining)
+                        if Keyword == "if":
+                            ElifStack.append(0)
+                            IfStack.append(Result)
+                        else:   #elseif
+                            if IfStack:
+                                IfStack[-1] = not IfStack[-1]
+                                IfStack.append(Result)
+                                ElifStack[-1] = ElifStack[-1] + 1
+                            else:
+                                raise Exception ("ERROR: No paired '!if' found for '!elif' for line '%s'" % DscLine)
+                    else:
+                        if IfStack:
+                            Handle = reduce(lambda x,y: x and y, IfStack)
+                        else:
+                            Handle = True
+                        if Handle:
+                            if Keyword == 'include':
+                                Remaining = self.ExpandMacros(Remaining)
+                                # Relative to DSC filepath
+                                IncludeFilePath = os.path.join(os.path.dirname(self._DscFile), Remaining)
+                                if not os.path.exists(IncludeFilePath):
+                                    # Relative to repository to find dsc in common platform
+                                    IncludeFilePath = os.path.join(os.path.dirname (self._DscFile), "..", Remaining)
+
+                                try:
+                                    IncludeDsc  = open(IncludeFilePath, "r")
+                                except:
+                                    raise Exception ("ERROR: Cannot open file '%s'." % IncludeFilePath)
+                                NewDscLines = IncludeDsc.readlines()
+                                IncludeDsc.close()
+                                DscLines = NewDscLines + DscLines
+                                del self._DscLines[-1]
+                            else:
+                                if DscLine.startswith('!'):
+                                    raise Exception ("ERROR: Unrecoginized directive for line '%s'" % DscLine)
+
+            if not Handle:
+                del self._DscLines[-1]
+                continue
+
+            if IsDefSect:
+                Match = re.match("^\s*(?:DEFINE\s+)*(\w+)\s*=\s*(.+)", DscLine)
+                if Match:
+                    self._MacroDict[Match.group(1)] = Match.group(2)
+                    if self.Debug:
+                        print ("INFO : DEFINE %s = [ %s ]" % (Match.group(1), Match.group(2)))
+
+            elif IsPcdSect:
+                Match = re.match("^\s*([\w\.]+)\s*\|\s*(\w+)", DscLine)
+                if Match:
+                    self._PcdsDict[Match.group(1)] = Match.group(2)
+                    if self.Debug:
+                        print ("INFO : PCD %s = [ %s ]" % (Match.group(1), Match.group(2)))
+
+            elif IsTmpSect:
+                # !BSF DEFT:{GPIO_TMPL:START}
+                Match = re.match("^\s*#\s+(!BSF)\s+DEFT:{(.+?):(START|END)}", DscLine)
+                if Match:
+                    if Match.group(3) == 'START' and not TemplateName:
+                        TemplateName = Match.group(2).strip()
+                        self._BsfTempDict[TemplateName] = []
+                    if Match.group(3) == 'END' and (TemplateName == Match.group(2).strip()) and TemplateName:
+                        TemplateName = ''
+                else:
+                    if TemplateName:
+                        Match = re.match("^!include\s*(.+)?$", DscLine)
+                        if Match:
+                            continue
+                        self._BsfTempDict[TemplateName].append(DscLine)
+
+            else:
+                Match = re.match("^\s*#\s+(!BSF|!HDR)\s+(.+)", DscLine)
+                if Match:
+                    Remaining = Match.group(2)
+                    if Match.group(1) == '!BSF':
+                        Result = BsfRegExp.findall (Remaining)
+                        if Result:
+                            for Each in Result:
+                                Key       = Each[0]
+                                Remaining = Each[1]
+
+                                if   Key   == 'BLOCK':
+                                    Match = re.match("NAME:\"(.+)\"\s*,\s*VER:\"(.+)\"\s*", Remaining)
+                                    if Match:
+                                        self._CfgBlkDict['name'] = Match.group(1)
+                                        self._CfgBlkDict['ver']  = Match.group(2)
+
+                                elif Key == 'SUBT':
+                                    #GPIO_TMPL:1:2:3
+                                    Remaining = Remaining.strip()
+                                    Match = re.match("(\w+)\s*:", Remaining)
+                                    if Match:
+                                        TemplateName = Match.group(1)
+                                        for Line in self._BsfTempDict[TemplateName][::-1]:
+                                            NewLine = self.SubtituteLine (Line, Remaining)
+                                            DscLines.insert(0, NewLine)
+                                            SkipLines += 1
+
+                                elif Key   == 'PAGES':
+                                    # !BSF PAGES:{HSW:"Haswell System Agent", LPT:"Lynx Point PCH"}
+                                    PageList = Remaining.split(',')
+                                    for Page in PageList:
+                                        Page  = Page.strip()
+                                        Match = re.match('(\w+):(\w*:)?\"(.+)\"', Page)
+                                        if Match:
+                                            PageName   = Match.group(1)
+                                            ParentName = Match.group(2)
+                                            if not ParentName or ParentName == ':' :
+                                                ParentName = 'root'
+                                            else:
+                                                ParentName = ParentName[:-1]
+                                            if not self.AddBsfChildPage (PageName, ParentName):
+                                                raise Exception("Cannot find parent page '%s'!" % ParentName)
+                                            self._CfgPageDict[PageName] = Match.group(3)
+                                        else:
+                                            raise Exception("Invalid page definitions '%s'!" % Page)
+
+                                elif Key in ['NAME', 'HELP', 'OPTION'] and Remaining.startswith('+'):
+                                    # Allow certain options to be extended to multiple lines
+                                    ConfigDict[Key.lower()] += Remaining[1:]
+
+                                else:
+                                    if Key == 'NAME':
+                                        Remaining = Remaining.strip()
+                                    elif Key == 'CONDITION':
+                                        Remaining = self.ExpandMacros(Remaining.strip())
+                                    ConfigDict[Key.lower()]  = Remaining
+                    else:
+                        Match = HdrRegExp.match(Remaining)
+                        if Match:
+                            Key = Match.group(1)
+                            Remaining = Match.group(2)
+                            if Key  == 'EMBED':
+                                Parts = Remaining.split(':')
+                                Names = Parts[0].split(',')
+                                DummyDict = ConfigDict.copy()
+                                if len(Names) > 1:
+                                    Remaining = Names[0] + ':' + ':'.join(Parts[1:])
+                                    DummyDict['struct'] = Names[1]
+                                else:
+                                    DummyDict['struct'] = Names[0]
+                                DummyDict['cname']   = 'Dummy'
+                                DummyDict['name']    = ''
+                                DummyDict['embed']   = Remaining
+                                DummyDict['offset']  = Offset
+                                DummyDict['length']  = 0
+                                DummyDict['value']   = '0'
+                                DummyDict['type']    = 'Reserved'
+                                DummyDict['help']    = ''
+                                DummyDict['subreg']  = []
+                                self._CfgItemList.append(DummyDict)
+                            else:
+                                ConfigDict[Key.lower()] = Remaining
+                # Check CFG line
+                #   gCfgData.VariableName   |    * | 0x01 | 0x1
+                Clear = False
+
+                Match = TksRegExp.match (DscLine)
+                if Match:
+                    DscLine = 'gCfgData.%s' % Match.group(2)
+
+                if DscLine.startswith('gCfgData.'):
+                    Match = CfgRegExp.match(DscLine[9:])
+                else:
+                    Match = None
+                if Match:
+                    ConfigDict['space']  = 'gCfgData'
+                    ConfigDict['cname']  = Match.group(1)
+                    if Match.group(2) != '*':
+                        Offset =  int (Match.group(2), 16)
+                    ConfigDict['offset'] = Offset
+                    ConfigDict['order']  = self.GetOrderNumber (ConfigDict['offset'], ConfigDict['order'])
+
+                    Value = Match.group(4).strip()
+                    if Match.group(3).startswith("0x"):
+                        Length  = int (Match.group(3), 16)
+                    else :
+                        Length  = int (Match.group(3))
+
+                    Offset += Length
+
+                    ConfigDict['length'] = Length
+                    Match = re.match("\$\((\w+)\)", Value)
+                    if Match:
+                        if Match.group(1) in self._MacroDict:
+                            Value = self._MacroDict[Match.group(1)]
+
+                    ConfigDict['value']  = Value
+                    if re.match("\{\s*FILE:(.+)\}", Value):
+                        # Expand embedded binary file
+                        ValArray = self.ValueToByteArray (ConfigDict['value'], ConfigDict['length'])
+                        NewValue = Bytes2Str(ValArray)
+                        self._DscLines[-1] = re.sub(r'(.*)(\{\s*FILE:.+\})' , r'\1 %s' % NewValue, self._DscLines[-1])
+                        ConfigDict['value']  = NewValue
+
+                    if ConfigDict['name']  == '':
+                        # Clear BSF specific items
+                        ConfigDict['bsfname'] = ''
+                        ConfigDict['help']   = ''
+                        ConfigDict['type']   = ''
+                        ConfigDict['option'] = ''
+
+                    self.CfgDuplicationCheck (CfgDict, ConfigDict['cname'])
+                    self._CfgItemList.append(ConfigDict.copy())
+                    Clear = True
+
+                else:
+                    # It could be a virtual item as below
+                    # !BSF FIELD:{SerialDebugPortAddress0:1}
+                    # or
+                    # @Bsf FIELD:{SerialDebugPortAddress0:1b}
+                    Match = re.match("^\s*#\s+(!BSF)\s+FIELD:{(.+)}", DscLine)
+                    if Match:
+                        BitFieldTxt = Match.group(2)
+                        Match = re.match("(.+):(\d+)b([BWDQ])?", BitFieldTxt)
+                        if not Match:
+                            raise Exception ("Incorrect bit field format '%s' !" % BitFieldTxt)
+                        UnitBitLen = 1
+                        SubCfgDict = ConfigDict.copy()
+                        SubCfgDict['cname']  = Match.group(1)
+                        SubCfgDict['bitlength'] = int (Match.group(2)) * UnitBitLen
+                        if SubCfgDict['bitlength'] > 0:
+                            LastItem =  self._CfgItemList[-1]
+                            if len(LastItem['subreg']) == 0:
+                                SubOffset  = 0
+                            else:
+                                SubOffset  = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']
+                            if Match.group(3) == 'B':
+                                SubCfgDict['bitunit'] = 1
+                            elif Match.group(3) == 'W':
+                                SubCfgDict['bitunit'] = 2
+                            elif Match.group(3) == 'Q':
+                                SubCfgDict['bitunit'] = 8
+                            else:
+                                SubCfgDict['bitunit'] = 4
+                            SubCfgDict['bitoffset'] = SubOffset
+                            SubCfgDict['order'] = self.GetOrderNumber (SubCfgDict['offset'], SubCfgDict['order'], SubOffset)
+                            SubCfgDict['value'] = ''
+                            SubCfgDict['cname'] = '%s_%s' % (LastItem['cname'], Match.group(1))
+                            self.CfgDuplicationCheck (CfgDict, SubCfgDict['cname'])
+                            LastItem['subreg'].append (SubCfgDict.copy())
+                        Clear = True
+
+                if Clear:
+                    ConfigDict['name']      = ''
+                    ConfigDict['find']      = ''
+                    ConfigDict['struct']    = ''
+                    ConfigDict['embed']     = ''
+                    ConfigDict['marker']    = ''
+                    ConfigDict['comment']   = ''
+                    ConfigDict['order']     = -1
+                    ConfigDict['subreg']    = []
+                    ConfigDict['option']    = ''
+                    ConfigDict['condition'] = ''
+
+        return Error
+
+    def GetBsfBitFields (self, subitem, bytes):
+        start = subitem['bitoffset']
+        end   = start + subitem['bitlength']
+        bitsvalue = ''.join('{0:08b}'.format(i) for i in bytes[::-1])
+        bitsvalue = bitsvalue[::-1]
+        bitslen   = len(bitsvalue)
+        if start > bitslen or end > bitslen:
+            raise Exception ("Invalid bits offset [%d,%d] %d for %s" % (start, end, bitslen, subitem['name']))
+        return '0x%X' % (int(bitsvalue[start:end][::-1], 2))
+
+    def UpdateBsfBitFields (self, SubItem, NewValue, ValueArray):
+        Start = SubItem['bitoffset']
+        End   = Start + SubItem['bitlength']
+        Blen  = len (ValueArray)
+        BitsValue = ''.join('{0:08b}'.format(i) for i in ValueArray[::-1])
+        BitsValue = BitsValue[::-1]
+        BitsLen   = len(BitsValue)
+        if Start > BitsLen or End > BitsLen:
+            raise Exception ("Invalid bits offset [%d,%d] %d for %s" % (Start, End, BitsLen, SubItem['name']))
+        BitsValue = BitsValue[:Start] + '{0:0{1}b}'.format(NewValue, SubItem['bitlength'])[::-1] + BitsValue[End:]
+        ValueArray[:]  = bytearray.fromhex('{0:0{1}x}'.format(int(BitsValue[::-1], 2), Blen * 2))[::-1]
+
+    def CreateVarDict (self):
+        Error = 0
+        self._VarDict = {}
+        if len(self._CfgItemList) > 0:
+            Item = self._CfgItemList[-1]
+            self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])
+        for Item in self._CfgItemList:
+            Embed = Item['embed']
+            Match = re.match("^(\w+):(\w+):(START|END)", Embed)
+            if Match:
+                StructName = Match.group(1)
+                VarName = '_%s_%s_' % (Match.group(3), StructName)
+                if Match.group(3) == 'END':
+                    self._VarDict[VarName] = Item['offset'] + Item['length']
+                    self._VarDict['_LENGTH_%s_' % StructName] = \
+                        self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]
+                    if Match.group(2).startswith('TAG_'):
+                        if (self.Mode != 'FSP') and (self._VarDict['_LENGTH_%s_' % StructName] % 4):
+                            raise Exception("Size of structure '%s' is %d, not DWORD aligned !" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))
+                        self._VarDict['_TAG_%s_' % StructName] = int (Match.group(2)[4:], 16) & 0xFFF
+                else:
+                    self._VarDict[VarName] = Item['offset']
+            if Item['marker']:
+                self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']
+        return Error
+
+    def UpdateBsfBitUnit (self, Item):
+        BitTotal  = 0
+        BitOffset = 0
+        StartIdx  = 0
+        Unit      = None
+        UnitDec   = {1:'BYTE', 2:'WORD', 4:'DWORD', 8:'QWORD'}
+        for Idx, SubItem in enumerate(Item['subreg']):
+            if Unit is None:
+                Unit  = SubItem['bitunit']
+            BitLength = SubItem['bitlength']
+            BitTotal  += BitLength
+            BitOffset += BitLength
+
+            if BitOffset > 64 or BitOffset > Unit * 8:
+                break
+
+            if BitOffset == Unit * 8:
+                for SubIdx in range (StartIdx, Idx + 1):
+                    Item['subreg'][SubIdx]['bitunit'] = Unit
+                BitOffset = 0
+                StartIdx  = Idx + 1
+                Unit      = None
+
+        if BitOffset > 0:
+            raise Exception ("Bit fields cannot fit into %s for '%s.%s' !" % (UnitDec[Unit], Item['cname'], SubItem['cname']))
+
+        ExpectedTotal = Item['length'] * 8
+        if Item['length'] * 8 != BitTotal:
+            raise Exception ("Bit fields total length (%d) does not match length (%d) of '%s' !" % (BitTotal, ExpectedTotal, Item['cname']))
+
+    def UpdateDefaultValue (self):
+        Error = 0
+        for Idx, Item in enumerate(self._CfgItemList):
+            if len(Item['subreg']) == 0:
+                Value = Item['value']
+                if (len(Value) > 0) and (Value[0] == '{' or Value[0] == "'" or Value[0] == '"'):
+                    # {XXX} or 'XXX' strings
+                    self.FormatListValue(self._CfgItemList[Idx])
+                else:
+                  Match = re.match("(0x[0-9a-fA-F]+|[0-9]+)", Value)
+                  if not Match:
+                    NumValue = self.EvaluateExpress (Value)
+                    Item['value'] = '0x%X' % NumValue
+            else:
+                ValArray = self.ValueToByteArray (Item['value'], Item['length'])
+                for SubItem in Item['subreg']:
+                    SubItem['value']   = self.GetBsfBitFields(SubItem, ValArray)
+                self.UpdateBsfBitUnit (Item)
+        return Error
+
+    @staticmethod
+    def ExpandIncludeFiles (FilePath, CurDir = ''):
+        if CurDir == '':
+            CurDir   = os.path.dirname(FilePath)
+            FilePath = os.path.basename(FilePath)
+
+        InputFilePath = os.path.join(CurDir, FilePath)
+        File  = open(InputFilePath, "r")
+        Lines = File.readlines()
+        File.close()
+
+        NewLines = []
+        for LineNum, Line in enumerate(Lines):
+            Match = re.match("^!include\s*(.+)?$", Line)
+            if Match:
+                IncPath = Match.group(1)
+                TmpPath = os.path.join(CurDir, IncPath)
+                OrgPath = TmpPath
+                if not os.path.exists(TmpPath):
+                    CurDir = os.path.join(os.path.dirname (os.path.realpath(__file__)), "..", "..")
+                TmpPath = os.path.join(CurDir, IncPath)
+                if not os.path.exists(TmpPath):
+                    raise Exception ("ERROR: Cannot open include file '%s'." % OrgPath)
+                else:
+                    NewLines.append (('# Included from file: %s\n' % IncPath, TmpPath, 0))
+                    NewLines.append (('# %s\n' % ('=' * 80), TmpPath, 0))
+                    NewLines.extend (CGenCfgData.ExpandIncludeFiles (IncPath, CurDir))
+            else:
+                NewLines.append ((Line, InputFilePath, LineNum))
+
+        return NewLines
+
+    def OverrideDefaultValue (self, DltFile):
+        Error    = 0
+        DltLines = CGenCfgData.ExpandIncludeFiles (DltFile);
+
+        PlatformId  = None
+        for Line, FilePath, LineNum in DltLines:
+          Line = Line.strip()
+          if not Line or Line.startswith('#'):
+            continue
+          Match = re.match("\s*(\w+)\.(\w+)(\.\w+)?\s*\|\s*(.+)", Line)
+          if not Match:
+            raise Exception("Unrecognized line '%s' (File:'%s' Line:%d) !" % (Line, FilePath, LineNum + 1))
+
+          Found   = False
+          InScope = False
+          for Idx, Item in enumerate(self._CfgItemList):
+            if not InScope:
+              if not (Item['embed'].endswith(':START') and Item['embed'].startswith(Match.group(1))):
+                continue
+              InScope = True
+            if Item['cname'] == Match.group(2):
+              Found = True
+              break
+            if Item['embed'].endswith(':END') and Item['embed'].startswith(Match.group(1)):
+              break
+          Name = '%s.%s' % (Match.group(1),Match.group(2))
+          if not Found:
+              ErrItem = Match.group(2) if InScope else Match.group(1)
+              raise Exception("Invalid configuration '%s' in '%s' (File:'%s' Line:%d) !" %
+                    (ErrItem, Name, FilePath, LineNum + 1))
+
+          ValueStr = Match.group(4).strip()
+          if Match.group(3) is not None:
+              # This is a subregion item
+              BitField = Match.group(3)[1:]
+              Found = False
+              if len(Item['subreg']) > 0:
+                  for SubItem in Item['subreg']:
+                      if SubItem['cname'] == '%s_%s' % (Item['cname'], BitField):
+                          Found = True
+                          break
+              if not Found:
+                  raise Exception("Invalid configuration bit field '%s' in '%s.%s' (File:'%s' Line:%d) !" %
+                        (BitField, Name, BitField, FilePath, LineNum + 1))
+
+              try:
+                  Value = int(ValueStr, 16) if ValueStr.startswith('0x') else int(ValueStr, 10)
+              except:
+                  raise Exception("Invalid value '%s' for bit field '%s.%s' (File:'%s' Line:%d) !" %
+                        (ValueStr, Name, BitField, FilePath, LineNum + 1))
+
+              if Value >= 2 ** SubItem['bitlength']:
+                  raise Exception("Invalid configuration bit field value '%s' for '%s.%s' (File:'%s' Line:%d) !" %
+                        (Value, Name, BitField, FilePath, LineNum + 1))
+
+              ValArray = self.ValueToByteArray (Item['value'], Item['length'])
+              self.UpdateBsfBitFields (SubItem, Value, ValArray)
+
+              if Item['value'].startswith('{'):
+                  Item['value'] = '{' + ', '.join('0x%02X' % i for i in ValArray) + '}'
+              else:
+                  BitsValue = ''.join('{0:08b}'.format(i) for i in ValArray[::-1])
+                  Item['value'] = '0x%X' % (int(BitsValue, 2))
+          else:
+              if Item['value'].startswith('{') and  not ValueStr.startswith('{'):
+                  raise Exception("Data array required for '%s' (File:'%s' Line:%d) !" % (Name, FilePath, LineNum + 1))
+              Item['value'] = ValueStr
+
+          if Name == 'PLATFORMID_CFG_DATA.PlatformId':
+              PlatformId = ValueStr
+
+        if (PlatformId is None) and (self.Mode != 'FSP'):
+            raise Exception("PLATFORMID_CFG_DATA.PlatformId is missing in file '%s' !" % (DltFile))
+
+        return Error
+
+    def ProcessMultilines (self, String, MaxCharLength):
+        Multilines = ''
+        StringLength = len(String)
+        CurrentStringStart = 0
+        StringOffset = 0
+        BreakLineDict = []
+        if len(String) <= MaxCharLength:
+            while (StringOffset < StringLength):
+                if StringOffset >= 1:
+                    if String[StringOffset - 1] == '\\' and String[StringOffset] == 'n':
+                        BreakLineDict.append (StringOffset + 1)
+                StringOffset += 1
+            if BreakLineDict != []:
+                for Each in BreakLineDict:
+                    Multilines += "  %s\n" % String[CurrentStringStart:Each].lstrip()
+                    CurrentStringStart = Each
+                if StringLength - CurrentStringStart > 0:
+                    Multilines += "  %s\n" % String[CurrentStringStart:].lstrip()
+            else:
+                Multilines = "  %s\n" % String
+        else:
+            NewLineStart = 0
+            NewLineCount = 0
+            FoundSpaceChar = False
+            while (StringOffset < StringLength):
+                if StringOffset >= 1:
+                    if NewLineCount >= MaxCharLength - 1:
+                        if String[StringOffset] == ' ' and StringLength - StringOffset > 10:
+                            BreakLineDict.append (NewLineStart + NewLineCount)
+                            NewLineStart = NewLineStart + NewLineCount
+                            NewLineCount = 0
+                            FoundSpaceChar = True
+                        elif StringOffset == StringLength - 1 and FoundSpaceChar == False:
+                            BreakLineDict.append (0)
+                    if String[StringOffset - 1] == '\\' and String[StringOffset] == 'n':
+                        BreakLineDict.append (StringOffset + 1)
+                        NewLineStart = StringOffset + 1
+                        NewLineCount = 0
+                StringOffset += 1
+                NewLineCount += 1
+            if BreakLineDict != []:
+                BreakLineDict.sort ()
+                for Each in BreakLineDict:
+                    if Each > 0:
+                        Multilines += "  %s\n" % String[CurrentStringStart:Each].lstrip()
+                    CurrentStringStart = Each
+                if StringLength - CurrentStringStart > 0:
+                    Multilines += "  %s\n" % String[CurrentStringStart:].lstrip()
+        return Multilines
+
+    def CreateField (self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength = None):
+        PosName    = 28
+        PosComment = 30
+        NameLine=''
+        HelpLine=''
+        OptionLine=''
+
+        if Length == 0 and Name == 'Dummy':
+            return '\n'
+
+        IsArray = False
+        if Length in [1,2,4,8]:
+            Type = "UINT%d" % (Length * 8)
+        else:
+            IsArray = True
+            Type = "UINT8"
+
+        if Item and Item['value'].startswith('{'):
+            Type = "UINT8"
+            IsArray = True
+
+        if Struct != '':
+            Type = Struct
+            if Struct in ['UINT8','UINT16','UINT32','UINT64']:
+                IsArray = True
+                Unit = int(Type[4:]) // 8
+                Length = Length / Unit
+            else:
+                IsArray = False
+
+        if IsArray:
+            Name = Name + '[%d]' % Length
+
+        if len(Type) < PosName:
+            Space1 = PosName - len(Type)
+        else:
+            Space1 = 1
+
+        if BsfName != '':
+            NameLine=" %s\n" % BsfName
+        else:
+            NameLine="\n"
+
+        if Help != '':
+            HelpLine = self.ProcessMultilines (Help, 80)
+
+        if Option != '':
+            OptionLine = self.ProcessMultilines (Option, 80)
+
+        if Offset is None:
+            OffsetStr = '????'
+        else:
+            OffsetStr = '0x%04X' % Offset
+
+        if BitsLength is None:
+            BitsLength = ''
+        else:
+            BitsLength = ' : %d' % BitsLength
+
+        return "\n/** %s%s%s**/\n  %s%s%s%s;\n" % (NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)
+
+    def SplitTextBody (self, TextBody):
+        Marker1 = '{ /* _COMMON_STRUCT_START_ */'
+        Marker2 = '; /* _COMMON_STRUCT_END_ */'
+        ComBody = []
+        TxtBody = []
+        IsCommon = False
+        for Line in TextBody:
+            if Line.strip().endswith(Marker1):
+                Line = Line.replace(Marker1[1:], '')
+                IsCommon = True
+            if Line.strip().endswith(Marker2):
+                Line = Line.replace(Marker2[1:], '')
+                if IsCommon:
+                    ComBody.append(Line)
+                    IsCommon = False
+                    continue
+            if IsCommon:
+                ComBody.append(Line)
+            else:
+                TxtBody.append(Line)
+        return ComBody, TxtBody
+
+    def GetStructArrayInfo (self, Input):
+        ArrayStr = Input.split('[')
+        Name     = ArrayStr[0]
+        if len(ArrayStr) > 1:
+            NumStr = ''.join(c for c in ArrayStr[-1] if c.isdigit())
+            NumStr = '1000' if len(NumStr) == 0 else NumStr
+            ArrayNum = int(NumStr)
+        else:
+            ArrayNum = 0
+        return Name, ArrayNum
+
+
+    def PostProcessBody (self, TextBody, IncludeEmbedOnly = True):
+        NewTextBody = []
+        OldTextBody = []
+        IncTextBody = []
+        StructBody  = []
+        IncludeLine = False
+        LineIsDef   = False
+        EmbedFound  = False
+        StructName  = ''
+        ArrayVarName   = ''
+        VariableName   = ''
+        Count          = 0
+        Level          = 0
+        BaseOffset     = 0
+        IsCommonStruct = False
+
+        for Line in TextBody:
+            if Line.startswith('#define '):
+                IncTextBody.append(Line)
+                continue
+
+            if not Line.startswith ('/* EMBED_STRUCT:'):
+                Match = False
+            else:
+                Match = re.match("^/\*\sEMBED_STRUCT:([\w\[\]\*]+):([\w\[\]\*]+):(\w+):(START|END)([\s\d]+)\*/([\s\S]*)", Line)
+
+            if Match:
+                ArrayMarker = Match.group(5)
+                if Match.group(4) == 'END':
+                    Level -= 1
+                    if Level == 0:
+                        Line = Match.group(6)
+                else:   # 'START'
+                    Level += 1
+                    if Level == 1:
+                        Line = Match.group(6)
+                    else:
+                        EmbedFound  = True
+                    TagStr = Match.group(3)
+                    if TagStr.startswith('TAG_'):
+                        try:
+                            TagVal = int(TagStr[4:], 16)
+                        except:
+                            TagVal = -1
+                        if (TagVal >= 0) and (TagVal < self._MinCfgTagId):
+                            IsCommonStruct = True
+
+                    if Level == 1:
+                        if  IsCommonStruct:
+                            Suffix = ' /* _COMMON_STRUCT_START_ */'
+                        else:
+                            Suffix = ''
+                        StructBody = ['typedef struct {%s' % Suffix]
+                        StructName   = Match.group(1)
+                        StructType   = Match.group(2)
+                        VariableName = Match.group(3)
+                        MatchOffset = re.search('/\*\*\sOffset\s0x([a-fA-F0-9]+)', Line)
+                        if MatchOffset:
+                            Offset = int(MatchOffset.group(1), 16)
+                        else:
+                            Offset = None
+                        IncludeLine = True
+                        BaseOffset  = Offset
+
+                        ModifiedStructType = StructType.rstrip()
+                        if ModifiedStructType.endswith(']'):
+                            Idx = ModifiedStructType.index('[')
+                            if ArrayMarker != ' ':
+                                # Auto array size
+                                OldTextBody.append('')
+                                ArrayVarName = VariableName
+                                if int(ArrayMarker) == 1000:
+                                    Count        = 1
+                                else:
+                                    Count        = int(ArrayMarker) + 1000
+                            else:
+                                if Count < 1000:
+                                    Count       += 1
+
+                            VariableTemp = ArrayVarName + '[%d]' % (Count if Count < 1000 else Count - 1000)
+                            OldTextBody[-1] = self.CreateField (None, VariableTemp, 0, Offset, ModifiedStructType[:Idx], '', 'Structure Array', '')
+                        else:
+                            ArrayVarName = ''
+                            OldTextBody.append (self.CreateField (None, VariableName, 0, Offset, ModifiedStructType, '', '', ''))
+
+            if IncludeLine:
+                StructBody.append (Line)
+            else:
+                OldTextBody.append (Line)
+
+            if Match and Match.group(4) == 'END':
+                if Level == 0:
+                    if (StructType != Match.group(2)) or (VariableName != Match.group(3)):
+                        print ("Unmatched struct name '%s' and '%s' !"  % (StructName, Match.group(2)))
+                    else:
+                        if  IsCommonStruct:
+                            Suffix = ' /* _COMMON_STRUCT_END_ */'
+                        else:
+                            Suffix = ''
+                        Line = '} %s;%s\n\n\n' % (StructName, Suffix)
+                        StructBody.append (Line)
+                        if (Line not in NewTextBody) and (Line not in OldTextBody):
+                            NewTextBody.extend (StructBody)
+                    IncludeLine = False
+                    BaseOffset  = 0
+                IsCommonStruct = False
+
+        if not IncludeEmbedOnly:
+            NewTextBody.extend(OldTextBody)
+
+        if EmbedFound:
+            NewTextBody = self.PostProcessBody (NewTextBody, False)
+
+        NewTextBody = IncTextBody + NewTextBody
+        return NewTextBody
+
+    def WriteHeaderFile (self, TxtBody, FileName, Type = 'h'):
+        FileNameDef = os.path.basename(FileName).replace ('.', '_')
+        FileNameDef = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', FileNameDef)
+        FileNameDef = re.sub('([a-z0-9])([A-Z])', r'\1_\2', FileNameDef).upper()
+
+        Lines = []
+        Lines.append ("%s\n"   % GetCopyrightHeader(Type))
+        Lines.append ("#ifndef __%s__\n"   % FileNameDef)
+        Lines.append ("#define __%s__\n\n" % FileNameDef)
+        if Type == 'h':
+            Lines.append ("#pragma pack(1)\n\n")
+        Lines.extend (TxtBody)
+        if Type == 'h':
+            Lines.append ("#pragma pack()\n\n")
+        Lines.append ("#endif\n")
+
+        # Don't rewrite if the contents are the same
+        Create = True
+        if os.path.exists(FileName):
+            HdrFile  = open(FileName, "r")
+            OrgTxt   = HdrFile.read()
+            HdrFile.close()
+
+            NewTxt   = ''.join(Lines)
+            if OrgTxt == NewTxt:
+                Create = False
+
+        if Create:
+            HdrFile  = open(FileName, "w")
+            HdrFile.write (''.join(Lines))
+            HdrFile.close()
+
+    def CreateHeaderFile (self, HdrFileName, ComHdrFileName = ''):
+        CommentLine  = ''
+        LastStruct   = ''
+        NextOffset   = 0
+        SpaceIdx     = 0
+        Offset       = 0
+        FieldIdx     = 0
+        LastFieldIdx = 0
+        ResvOffset   = 0
+        ResvIdx      = 0
+        TxtBody      = []
+        LineBuffer   = []
+        CfgTags      = []
+        InRange      = True
+        LastVisible  = True
+
+        TxtBody.append("typedef struct {\n")
+        for Item in self._CfgItemList:
+            # Search for CFGDATA tags
+            Embed = Item["embed"].upper()
+            if Embed.endswith(':START'):
+                Match = re.match (r'(\w+)_CFG_DATA:TAG_([0-9A-F]+):START', Embed)
+                if Match:
+                    TagName = Match.group(1)
+                    TagId   = int(Match.group(2), 16)
+                    CfgTags.append ((TagId, TagName))
+
+            # Only process visible items
+            NextVisible = LastVisible
+
+            if LastVisible and (Item['header'] == 'OFF'):
+                NextVisible = False
+                ResvOffset  = Item['offset']
+            elif (not LastVisible) and Item['header'] == 'ON':
+                NextVisible = True
+                Name = "ReservedUpdSpace%d" % ResvIdx
+                ResvIdx = ResvIdx + 1
+                TxtBody.append(self.CreateField (Item, Name, Item["offset"] - ResvOffset, ResvOffset, '', '', '', ''))
+                FieldIdx += 1
+
+            if  Offset < Item["offset"]:
+                if LastVisible:
+                    Name = "UnusedUpdSpace%d" % SpaceIdx
+                    LineBuffer.append(self.CreateField (Item, Name, Item["offset"] - Offset, Offset, '', '', '', ''))
+                    FieldIdx += 1
+                SpaceIdx = SpaceIdx + 1
+                Offset   = Item["offset"]
+
+            LastVisible = NextVisible
+
+            Offset = Offset + Item["length"]
+            if LastVisible:
+                for Each in LineBuffer:
+                    TxtBody.append (Each)
+                LineBuffer = []
+                Comment = Item["comment"]
+                Embed = Item["embed"].upper()
+                if Embed.endswith(':START') or Embed.endswith(':END'):
+                    # EMBED_STRUCT: StructName : ItemName : VariableName : START|END
+                    Name, ArrayNum = self.GetStructArrayInfo (Item["struct"])
+                    Remaining = Item["embed"]
+                    if (LastFieldIdx + 1 == FieldIdx) and (LastStruct == Name):
+                        ArrayMarker  = ' '
+                    else:
+                        ArrayMarker  = '%d' % ArrayNum
+                    LastFieldIdx = FieldIdx
+                    LastStruct   = Name
+                    Marker = '/* EMBED_STRUCT:%s:%s%s*/ ' % (Name, Remaining, ArrayMarker)
+                    #if Embed.endswith(':START') and Comment != '':
+                    #    Marker = '/* COMMENT:%s */ \n' % Item["comment"] + Marker
+                else:
+                    if Embed == '':
+                        Marker = ''
+                    else:
+                        self.Error = "Invalid embedded structure format '%s'!\n" % Item["embed"]
+                        return 4
+
+                # Generate bit fields for structure
+                if len(Item['subreg']) > 0 and Item["struct"]:
+                    StructType = Item["struct"]
+                    StructName, ArrayNum = self.GetStructArrayInfo (StructType)
+                    if (LastFieldIdx + 1 == FieldIdx) and (LastStruct == Item["struct"]):
+                        ArrayMarker = ' '
+                    else:
+                        ArrayMarker = '%d' % ArrayNum
+                    TxtBody.append('/* EMBED_STRUCT:%s:%s:%s:START%s*/\n' % (StructName, StructType, Item["cname"], ArrayMarker))
+                    for SubItem in Item['subreg']:
+                        Name = SubItem["cname"]
+                        if Name.startswith(Item["cname"]):
+                            Name = Name[len(Item["cname"]) + 1:]
+                        Line = self.CreateField (SubItem, Name, SubItem["bitunit"], SubItem["offset"], SubItem['struct'], SubItem['name'], SubItem['help'], SubItem['option'], SubItem['bitlength'])
+                        TxtBody.append(Line)
+                    TxtBody.append('/* EMBED_STRUCT:%s:%s:%s:END%s*/\n' % (StructName, StructType, Item["cname"], ArrayMarker))
+                    LastFieldIdx   = FieldIdx
+                    LastStruct     = Item["struct"]
+                    FieldIdx      += 1
+                else:
+                    FieldIdx += 1
+                    Line = Marker + self.CreateField (Item, Item["cname"], Item["length"], Item["offset"], Item['struct'], Item['name'], Item['help'], Item['option'])
+                    TxtBody.append(Line)
+
+        TxtBody.append("}\n\n")
+
+        # Handle the embedded data structure
+        TxtBody  = self.PostProcessBody (TxtBody)
+        ComBody, TxtBody = self.SplitTextBody (TxtBody)
+
+        # Prepare TAG defines
+        PltTagDefTxt = ['\n']
+        ComTagDefTxt = ['\n']
+        for TagId, TagName in sorted(CfgTags):
+            TagLine = '#define  %-30s  0x%03X\n' % ('CDATA_%s_TAG' % TagName, TagId)
+            if TagId < self._MinCfgTagId:
+                # TAG ID < 0x100, it is a generic TAG
+                ComTagDefTxt.append (TagLine)
+            else:
+                PltTagDefTxt.append (TagLine)
+        PltTagDefTxt.append ('\n\n')
+        ComTagDefTxt.append ('\n\n')
+
+        # Write file back
+        self.WriteHeaderFile (PltTagDefTxt + TxtBody, HdrFileName)
+        if ComHdrFileName:
+            self.WriteHeaderFile (ComTagDefTxt + ComBody, ComHdrFileName)
+
+        return 0
+
+    def UpdateConfigItemValue (self, Item, ValueStr):
+        IsArray  = True if Item['value'].startswith('{') else False
+        IsString = True if Item['value'].startswith("'") else False
+        Bytes = self.ValueToByteArray(ValueStr, Item['length'])
+        if IsString:
+            NewValue = "'%s'" % Bytes.decode("utf-8")
+        elif IsArray:
+            NewValue = Bytes2Str(Bytes)
+        else:
+            Fmt = '0x%X' if Item['value'].startswith('0x') else '%d'
+            NewValue = Fmt % Bytes2Val(Bytes)
+        Item['value'] = NewValue
+
+    def LoadDefaultFromBinaryArray (self, BinDat, IgnoreFind = False):
+        FindOff  = 0
+        StartOff = 0
+        for Item in self._CfgItemList:
+            if Item['length'] == 0:
+                continue
+            if not IgnoreFind and Item['find']:
+                FindBin = Item['find'].encode()
+                Offset = BinDat.find (FindBin)
+                if Offset >= 0:
+                    TestOff = BinDat[Offset+len(FindBin):].find (FindBin)
+                    if TestOff >= 0:
+                        raise Exception ('Multiple match found for "%s" !' % Item['find'])
+                    FindOff  = Offset + len(FindBin)
+                    StartOff = Item['offset']
+                else:
+                    raise Exception ('Could not find "%s" !' % Item['find'])
+            if Item['offset'] + Item['length'] > len(BinDat):
+                raise Exception ('Mismatching format between DSC and BIN files !')
+            Offset = FindOff + (Item['offset'] - StartOff)
+            ValStr = Bytes2Str(BinDat[Offset : Offset + Item['length']])
+            self.UpdateConfigItemValue (Item, ValStr)
+
+        self.UpdateDefaultValue()
+
+    def PatchBinaryArray (self, BinDat):
+        FileOff = 0
+        Offset  = 0
+        FindOff = 0
+
+        PatchList = []
+        CfgBin  = bytearray()
+        for Item in self._CfgItemList:
+            if Item['length'] == 0:
+                continue
+
+            if Item['find']:
+                if len(CfgBin) > 0:
+                    PatchList.append ((FileOff, CfgBin))
+                FindBin = Item['find'].encode()
+                FileOff = BinDat.find (FindBin)
+                if FileOff < 0:
+                    raise Exception ('Could not find "%s" !' % Item['find'])
+                else:
+                    TestOff = BinDat[FileOff+len(FindBin):].find (FindBin)
+                    if TestOff >= 0:
+                        raise Exception ('Multiple match found for "%s" !' % Item['find'])
+                FileOff += len(FindBin)
+                Offset  = Item['offset']
+                FindOff = Offset
+                CfgBin  = bytearray()
+
+            if Item['offset'] > Offset:
+                Gap = Item['offset'] - Offset
+                CfgBin.extend(b'\x00' * Gap)
+
+            if Item['type'] == 'Reserved' and Item['option'] == '$SKIP':
+                # keep old data
+                NewOff = FileOff + (Offset - FindOff)
+                FileData = bytearray(BinDat[NewOff: NewOff + Item['length']])
+                CfgBin.extend(FileData)
+            else:
+                CfgBin.extend(self.ValueToByteArray(Item['value'], Item['length']))
+            Offset = Item['offset'] + Item['length']
+
+        if len(CfgBin) > 0:
+            PatchList.append ((FileOff, CfgBin))
+
+        for FileOff, CfgBin in PatchList:
+            Length = len(CfgBin)
+            if FileOff + Length < len(BinDat):
+                BinDat[FileOff:FileOff+Length] = CfgBin[:]
+
+        return BinDat
+
+    def GenerateBinaryArray (self):
+        Offset = 0
+        BinDat = bytearray ()
+        for Item in self._CfgItemList:
+            if Item['offset'] > Offset:
+                Gap = Item['offset'] - Offset
+                BinDat.extend(b'\x00' * Gap)
+            BinDat.extend(self.ValueToByteArray(Item['value'], Item['length']))
+            Offset = Item['offset'] + Item['length']
+        return BinDat
+
+    def GenerateBinary (self, BinFileName):
+        BinFile = open(BinFileName, "wb")
+        BinFile.write (self.GenerateBinaryArray ())
+        BinFile.close()
+        return 0
+
+    def GenerateDataIncFile (self, DatIncFileName, BinFile = None):
+        # Put a prefix GUID before CFGDATA so that it can be located later on
+        Prefix   = b'\xa7\xbd\x7f\x73\x20\x1e\x46\xd6\xbe\x8f\x64\x12\x05\x8d\x0a\xa8'
+        if BinFile:
+            Fin = open (BinFile, 'rb')
+            BinDat = Prefix + bytearray(Fin.read())
+            Fin.close()
+        else:
+            BinDat = Prefix + self.GenerateBinaryArray ()
+
+        FileName = os.path.basename(DatIncFileName).upper()
+        FileName = FileName.replace('.', '_')
+
+        TxtLines = []
+
+        TxtLines.append ("UINT8  mConfigDataBlob[%d] = {\n" % len(BinDat))
+        Count = 0
+        Line  = ['  ']
+        for Each in BinDat:
+            Line.append('0x%02X, ' % Each)
+            Count = Count + 1
+            if (Count & 0x0F) == 0:
+                Line.append('\n')
+                TxtLines.append (''.join(Line))
+                Line  = ['  ']
+        if len(Line) > 1:
+            TxtLines.append (''.join(Line) + '\n')
+
+        TxtLines.append ("};\n\n")
+
+        self.WriteHeaderFile (TxtLines, DatIncFileName, 'inc')
+
+        return 0
+
+    def CheckCfgData (self):
+        # Check if CfgData contains any duplicated name
+        def  AddItem (Item, ChkList):
+            Name = Item['cname']
+            if Name in ChkList:
+                return Item
+            if Name not in ['Dummy', 'Reserved', 'CfgHeader', 'CondValue']:
+                ChkList.append(Name)
+            return None
+
+        Duplicate = None
+        ChkList   = []
+        for  Item in self._CfgItemList:
+            Duplicate = AddItem (Item, ChkList)
+            if not Duplicate:
+                for SubItem in Item['subreg']:
+                    Duplicate = AddItem (SubItem, ChkList)
+                    if Duplicate:
+                        break
+            if Duplicate:
+                break
+        if Duplicate:
+            self.Error = "Duplicated CFGDATA '%s' found !\n" % Duplicate['cname']
+            return -1
+        return 0
+
+    def PrintData (self):
+        for  Item in self._CfgItemList:
+            if not Item['length']:
+                continue
+            print ("%-10s @Offset:0x%04X  Len:%3d  Val:%s" % (Item['cname'], Item['offset'], Item['length'], Item['value']))
+            for  SubItem in Item['subreg']:
+                print ("  %-20s  BitOff:0x%04X  BitLen:%-3d  Val:%s" % (SubItem['cname'], SubItem['bitoffset'], SubItem['bitlength'], SubItem['value']))
+
+    def FormatArrayValue (self, Input, Length):
+        Dat = self.ValueToByteArray(Input, Length)
+        return ','.join('0x%02X' % Each for Each in Dat)
+
+    def GetItemOptionList (self, Item):
+        TmpList = []
+        if  Item['type'] == "Combo":
+            if not Item['option'] in self._BuidinOption:
+                OptList = Item['option'].split(',')
+                for Option in OptList:
+                    Option = Option.strip()
+                    try:
+                        (OpVal, OpStr) = Option.split(':')
+                    except:
+                        raise Exception("Invalide option format '%s' !" % Option)
+                    TmpList.append((OpVal, OpStr))
+        return  TmpList
+
+    def WriteBsfStruct  (self, BsfFd, Item):
+        if Item['type'] == "None":
+            Space = "gPlatformFspPkgTokenSpaceGuid"
+        else:
+            Space = Item['space']
+        Line = "    $%s_%s" % (Space, Item['cname'])
+        Match = re.match("\s*(\{.+\})\s*", Item['value'])
+        if Match:
+            DefaultValue = self.FormatArrayValue (Match.group(1).strip(), Item['length'])
+        else:
+            DefaultValue = Item['value'].strip()
+        if 'bitlength' in Item:
+            if Item['bitlength']:
+                BsfFd.write("    %s%s%4d bits     $_DEFAULT_ = %s\n" % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))
+        else:
+            if Item['length']:
+                BsfFd.write("    %s%s%4d bytes    $_DEFAULT_ = %s\n" % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))
+
+        return self.GetItemOptionList (Item)
+
+    def GetBsfOption (self, OptionName):
+        if OptionName in self._CfgOptsDict:
+            return self._CfgOptsDict[OptionName]
+        else:
+            return OptionName
+
+    def WriteBsfOption  (self, BsfFd, Item):
+        PcdName   = Item['space'] + '_' + Item['cname']
+        WriteHelp = 0
+        BsfLines  = []
+        if Item['type'] == "Combo":
+            if Item['option'] in self._BuidinOption:
+                Options = self._BuidinOption[Item['option']]
+            else:
+                Options = self.GetBsfOption (PcdName)
+            BsfLines.append ('    %s $%s, "%s", &%s,\n' % (Item['type'], PcdName, Item['name'], Options))
+            WriteHelp = 1
+        elif Item['type'].startswith("EditNum"):
+            Match = re.match("EditNum\s*,\s*(HEX|DEC)\s*,\s*\((\d+|0x[0-9A-Fa-f]+)\s*,\s*(\d+|0x[0-9A-Fa-f]+)\)", Item['type'])
+            if Match:
+                BsfLines.append ('    EditNum $%s, "%s", %s,\n' % (PcdName, Item['name'], Match.group(1)))
+                WriteHelp = 2
+        elif Item['type'].startswith("EditText"):
+            BsfLines.append ('    %s $%s, "%s",\n' % (Item['type'], PcdName, Item['name']))
+            WriteHelp = 1
+        elif Item['type'] == "Table":
+            Columns = Item['option'].split(',')
+            if len(Columns) != 0:
+                BsfLines.append('    %s $%s "%s",' % (Item['type'], PcdName, Item['name']))
+                for Col in Columns:
+                    Fmt = Col.split(':')
+                    if len(Fmt) != 3:
+                        raise Exception("Column format '%s' is invalid !" % Fmt)
+                    try:
+                        Dtype = int(Fmt[1].strip())
+                    except:
+                        raise Exception("Column size '%s' is invalid !" % Fmt[1])
+                    BsfLines.append('\n        Column "%s", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))
+                BsfLines.append(',\n')
+                WriteHelp = 1
+
+        if WriteHelp  > 0:
+            HelpLines = Item['help'].split('\\n\\r')
+            FirstLine = True
+            for HelpLine in HelpLines:
+                if FirstLine:
+                    FirstLine = False
+                    BsfLines.append('        Help "%s"\n' % (HelpLine))
+                else:
+                    BsfLines.append('             "%s"\n' % (HelpLine))
+            if WriteHelp == 2:
+                BsfLines.append('             "Valid range: %s ~ %s"\n' % (Match.group(2), Match.group(3)))
+
+            if len(Item['condition']) > 4:
+                CondList = Item['condition'].split(',')
+                Idx = 0
+                for Cond in CondList:
+                    Cond = Cond.strip()
+                    if   Cond.startswith('#'):
+                        BsfLines.insert(Idx, Cond + '\n')
+                        Idx += 1
+                    elif Cond.startswith('@#'):
+                        BsfLines.append(Cond[1:] + '\n')
+
+        for Line in BsfLines:
+            BsfFd.write (Line)
+
+    def WriteBsfPages (self, PageTree, BsfFd):
+        BsfFd.write('\n')
+        Key = next(iter(PageTree))
+        for Page in PageTree[Key]:
+            PageName = next(iter(Page))
+            BsfFd.write('Page "%s"\n' % self._CfgPageDict[PageName])
+            if len(PageTree[Key]):
+                self.WriteBsfPages (Page, BsfFd)
+
+            BsfItems = []
+            for Item in self._CfgItemList:
+                if Item['name'] != '':
+                    if Item['page'] != PageName:
+                        continue
+                    if len(Item['subreg']) > 0:
+                        for SubItem in Item['subreg']:
+                            if SubItem['name'] != '':
+                                BsfItems.append(SubItem)
+                    else:
+                        BsfItems.append(Item)
+
+            BsfItems.sort(key=lambda x: x['order'])
+
+            for Item in BsfItems:
+                self.WriteBsfOption (BsfFd, Item)
+            BsfFd.write("EndPage\n\n")
+
+    def GenerateBsfFile (self, BsfFile):
+
+        if BsfFile == '':
+            self.Error = "BSF output file '%s' is invalid" % BsfFile
+            return 1
+
+        Error = 0
+        OptionDict = {}
+        BsfFd      = open(BsfFile, "w")
+        BsfFd.write("%s\n" % GetCopyrightHeader('bsf'))
+        BsfFd.write("%s\n" % self._GlobalDataDef)
+        BsfFd.write("StructDef\n")
+        NextOffset = -1
+        for Item in self._CfgItemList:
+            if Item['find'] != '':
+                BsfFd.write('\n    Find "%s"\n' % Item['find'])
+                NextOffset = Item['offset'] + Item['length']
+            if Item['name'] != '':
+                if NextOffset != Item['offset']:
+                    BsfFd.write("        Skip %d bytes\n" % (Item['offset'] - NextOffset))
+                if len(Item['subreg']) > 0:
+                    NextOffset =  Item['offset']
+                    BitsOffset =  NextOffset * 8
+                    for SubItem in Item['subreg']:
+                        BitsOffset += SubItem['bitlength']
+                        if SubItem['name'] == '':
+                            if 'bitlength' in SubItem:
+                                BsfFd.write("        Skip %d bits\n" % (SubItem['bitlength']))
+                            else:
+                                BsfFd.write("        Skip %d bytes\n" % (SubItem['length']))
+                        else:
+                            Options = self.WriteBsfStruct(BsfFd, SubItem)
+                            if len(Options) > 0:
+                                OptionDict[SubItem['space']+'_'+SubItem['cname']] = Options
+
+                    NextBitsOffset = (Item['offset'] + Item['length']) * 8
+                    if NextBitsOffset > BitsOffset:
+                        BitsGap     = NextBitsOffset - BitsOffset
+                        BitsRemain  = BitsGap % 8
+                        if BitsRemain:
+                            BsfFd.write("        Skip %d bits\n" % BitsRemain)
+                            BitsGap -= BitsRemain
+                        BytesRemain = BitsGap // 8
+                        if BytesRemain:
+                            BsfFd.write("        Skip %d bytes\n" % BytesRemain)
+                    NextOffset = Item['offset'] + Item['length']
+                else:
+                    NextOffset = Item['offset'] + Item['length']
+                    Options = self.WriteBsfStruct(BsfFd, Item)
+                    if len(Options) > 0:
+                        OptionDict[Item['space']+'_'+Item['cname']] = Options
+        BsfFd.write("\nEndStruct\n\n")
+
+        BsfFd.write("%s" % self._BuidinOptionTxt)
+
+        NameList   = []
+        OptionList = []
+        for Each in sorted(OptionDict):
+            if OptionDict[Each] not in OptionList:
+                NameList.append(Each)
+                OptionList.append (OptionDict[Each])
+                BsfFd.write("List &%s\n" % Each)
+                for Item in OptionDict[Each]:
+                    BsfFd.write('    Selection %s , "%s"\n' % (self.EvaluateExpress(Item[0]), Item[1]))
+                BsfFd.write("EndList\n\n")
+            else:
+                # Item has idential options as other item
+                # Try to reuse the previous options instead
+                Idx = OptionList.index (OptionDict[Each])
+                self._CfgOptsDict[Each] = NameList[Idx]
+
+        BsfFd.write("BeginInfoBlock\n")
+        BsfFd.write('    PPVer       "%s"\n' % (self._CfgBlkDict['ver']))
+        BsfFd.write('    Description "%s"\n' % (self._CfgBlkDict['name']))
+        BsfFd.write("EndInfoBlock\n\n")
+
+        self.WriteBsfPages (self._CfgPageTree, BsfFd)
+
+        BsfFd.close()
+        return  Error
+
+    def WriteDeltaLine (self, OutLines, Name, ValStr, IsArray):
+        if IsArray:
+            Output = '%s | { %s }' % (Name, ValStr)
+        else:
+            Output = '%s | 0x%X' % (Name, Array2Val(ValStr))
+        OutLines.append (Output)
+
+    def WriteDeltaFile (self, OutFile, PlatformId, OutLines):
+        DltFd = open (OutFile, "w")
+        DltFd.write ("%s\n"   % GetCopyrightHeader('dlt', True))
+        if PlatformId is not None:
+            DltFd.write ('#\n')
+            DltFd.write ('# Delta configuration values for platform ID 0x%04X\n' % PlatformId)
+            DltFd.write ('#\n\n')
+        for Line in OutLines:
+            DltFd.write ('%s\n' % Line)
+        DltFd.close()
+
+    def GenerateDeltaFile (self, OutFile, AbsfFile):
+        # Parse ABSF Build in dict
+        if not os.path.exists(AbsfFile):
+            Lines = []
+        else:
+            with open(AbsfFile) as Fin:
+                Lines = Fin.readlines()
+
+        AbsfBuiltValDict = {}
+        Process = False
+        for Line in Lines:
+            Line = Line.strip()
+            if Line.startswith('StructDef'):
+                Process = True
+            if Line.startswith('EndStruct'):
+                break
+            if not Process:
+                continue
+            Match = re.match('\s*\$gCfgData_(\w+)\s+(\d+)\s+(bits|bytes)\s+\$_AS_BUILT_\s+=\s+(.+)\$', Line)
+            if Match:
+                if Match.group(1) not in AbsfBuiltValDict:
+                    AbsfBuiltValDict[Match.group(1)] = Match.group(4).strip()
+                else:
+                    raise Exception ("Duplicated configuration name '%s' found !", Match.group(1))
+
+        # Match config item in DSC
+        PlatformId = None
+        OutLines   = []
+        TagName    = ''
+        Level      = 0
+        for Item in self._CfgItemList:
+            Name = None
+            if Level == 0 and Item['embed'].endswith(':START'):
+                TagName = Item['embed'].split(':')[0]
+                Level  += 1
+            if Item['cname'] in AbsfBuiltValDict:
+                ValStr = AbsfBuiltValDict[Item['cname']]
+                Name   = '%s.%s' % (TagName, Item['cname'])
+                if not Item['subreg'] and Item['value'].startswith('{'):
+                    Value   = Array2Val(Item['value'])
+                    IsArray = True
+                else:
+                    Value   = int(Item['value'], 16)
+                    IsArray = False
+                AbsfVal = Array2Val(ValStr)
+                if AbsfVal != Value:
+                    if 'PLATFORMID_CFG_DATA.PlatformId' == Name:
+                        PlatformId = AbsfVal
+                    self.WriteDeltaLine (OutLines, Name, ValStr, IsArray)
+                else:
+                    if 'PLATFORMID_CFG_DATA.PlatformId' == Name:
+                        raise Exception ("'PlatformId' has the same value as DSC default !")
+
+            if Item['subreg']:
+                for SubItem in Item['subreg']:
+                    if SubItem['cname'] in AbsfBuiltValDict:
+                        ValStr = AbsfBuiltValDict[SubItem['cname']]
+                        if Array2Val(ValStr) == int(SubItem['value'], 16):
+                            continue
+                        Name   = '%s.%s.%s' % (TagName, Item['cname'], SubItem['cname'])
+                        self.WriteDeltaLine (OutLines, Name, ValStr, False)
+
+            if Item['embed'].endswith(':END'):
+                Level  -= 1
+
+        if PlatformId is None and Lines:
+            raise Exception ("'PlatformId' configuration is missing in ABSF file!")
+        else:
+            PlatformId = 0
+
+        self.WriteDeltaFile (OutFile, PlatformId, Lines)
+
+        return 0
+
+    def GenerateDscFile (self, OutFile):
+        DscFd = open(OutFile, "w")
+        for Line in self._DscLines:
+          DscFd.write (Line + '\n')
+        DscFd.close ()
+        return 0
+
 class CGenCfgOpt:
     def __init__(self):
         self.Debug          = False
@@ -313,7 +2280,6 @@ EndList
         self._DscFile     = ''
         self._FvDir       = ''
         self._MapVer      = 0
-        self._DscTime     = 0
 
     def ParseMacros (self, MacroDefStr):
         # ['-DABC=1', '-D', 'CFG_DEBUG=1', '-D', 'CFG_OUTDIR=Build']
@@ -424,9 +2390,6 @@ EndList
         self._DscFile     = DscFile
         self._FvDir       = FvDir
 
-        # Initial DSC time is parent DSC time.
-        self._DscTime     = os.path.getmtime(DscFile)
-
         IsDefSect       = False
         IsPcdSect       = False
         IsUpdSect       = False
@@ -534,12 +2497,6 @@ EndList
                                         if IncludeDsc == None:
                                             print("ERROR: Cannot open file '%s'" % IncludeFilePath)
                                             raise SystemExit
-
-                                        # Update DscTime when newer DSC time found.
-                                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))
-                                        if CurrentDscTime > self._DscTime:
-                                            self._DscTime = CurrentDscTime
-
                                         NewDscLines = IncludeDsc.readlines()
                                         IncludeDsc.close()
                                         DscLines = NewDscLines + DscLines
@@ -825,8 +2782,9 @@ EndList
         if not os.path.exists(OutPutFile):
             NoFileChange = False
         else:
+            DscTime = os.path.getmtime(self._DscFile)
             OutputTime = os.path.getmtime(OutPutFile)
-            if self._DscTime > OutputTime:
+            if DscTime > OutputTime:
                 NoFileChange = False
         return NoFileChange
 
diff --git a/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual.md b/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual.md
new file mode 100644
index 0000000000..e739ffc25e
--- /dev/null
+++ b/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual.md
@@ -0,0 +1,39 @@
+#Name
+**FspDscBsf2Yaml.py** The python script that generates YAML file for
+the Boot Settings from an EDK II Platform Description (**DSC**) file
+or from a Boot Settings File (**BSF**). It is created to help
+transitioning FSP Updateable Product Data (**UPD**) file format to
+new standardized YAML format so that it can be configured through
+open source tools.
+
+#Synopsis
+```
+FspDscBsf2Yaml DscFile|BsfFile  YamlFile
+```
+
+#Description
+**FspDscBsf2Yaml.py** is a script that generates configuration options from an
+**EDK II Platform Description (DSC)** file or **a Boot Settings File (BSF)** file.
+
+It generates a **YAML file** that can be used by the **Config Editor** to provide
+a graphical user interface for manipulating settings in the UPD regions.
+
+The following sections explain the usage of this script.
+
+## 1. FspDscBsf2Yaml.py DscFile YamlFile
+
+The **DscFile** option is an input DSC file.
+
+The **YamlFile** option is an output YAML file.
+
+The script takes the FSP DSC file consisting BSF syntax and generates a YAML
+output file describing the boot settings.
+
+## 2. FspDscBsf2Yaml.py BsfFile YamlFile
+
+The **BsfFile** option is an input BSF file.
+
+The **YamlFile** option is an output YAML file.
+
+The script generates a YAML output file from a BSF file. The BSF file
+can be generated using GenCfgOpt tool.
-- 
2.28.0.windows.1

